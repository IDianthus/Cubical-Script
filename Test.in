"Adventure":{"analyze loot":{:import adventure_lib\n:name {package}:analyze loot\n\n:global string leon.adventure.targetPositions\n\n:local string queue\n:local string idx\n:local vector curPos\n:local string targetPos\n:local string lootPositions\n\n#setField(index, value) lss (\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n#setTPos(index, value) lss (\"_t\" . {index}, {value})\n#getTPos(index) lsg(\"_t\" . {index})\n\nqueue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . \"S:\"\n\n; On the first entry of this loop, the junk entry \"_f\" will be set to \"S\".\n; This has no effect.\n; In general, lootPositions, queue and setField are protected so that if the field\n; has already been set, we won't take action again.\nloop1:\ncurPos = {firstElementPos}\nidx = sub (queue, 0, 4)\nlootPositions = if (\\n  {getField(idx)} == \"\"\\n    && contains(adventure.entityType(curPos), \"Chest\"),\\n  {posToString(x(curPos), y(curPos))} . \":\",\\n  \"\") . lootPositions\n{setField(if ({getField(idx)} != \"\", \"\", idx), {firstElementDir})}\nqueue = sub (queue, 6, 99999) . if ({getField(idx)} != {firstElementDir},\\n  \"\",\\n  if (\\n    adventure.isWall(curPos + vec(0., 1.)) || y(curPos) >= 18.,\\n    \"\",\\n    {posToString(x(curPos), y(curPos) + 1.)} . \"U:\"\) . if (\\n    adventure.isWall(curPos + vec(0., -1.)) || y(curPos) < 1.,\\n    \"\",\\n    {posToString(x(curPos), y(curPos) - 1.)} . \"D:\"\) . if (\\n    adventure.isWall(curPos + vec(1., 0.)) || x(curPos) >= 18.,\\n    \"\",\\n    {posToString(x(curPos) + 1., y(curPos))} . \"R:\"\) . if (\\n    adventure.isWall(curPos + vec(-1., 0.)) || x(curPos) < 1.,\\n    \"\",\\n    {posToString(x(curPos) - 1., y(curPos))} . \"L:\"\\)\\)\ngotoif (loop1, queue != \"\")\n\ncontinue:\nlootPositions = leon.adventure.targetPositions . lootPositions\n\nloop2:\ntargetPos = sub (lootPositions, 0, 4)\ncurPos = {strToVec(targetPos)}\nlootPositions = sub (lootPositions, 5, 99999)\n\ninnerLoop2:\nidx = {posToString(x(curPos), y(curPos))}\nleon.adventure.targetPositions = if (\\n  {getField({posToString(\\n    x(curPos) - {nextX({getField(idx)})},\\n    y(curPos) - {nextY({getField(idx)})}\)}\)} == \"S\"\\n    && false == contains(leon.adventure.targetPositions, targetPos),\\n  targetPos . \":\" . leon.adventure.targetPositions,\\n  if (\\n    false == contains(leon.adventure.targetPositions, targetPos) \\n      && {getTPos(idx)} != \"\",\\n      sub (\\n        leon.adventure.targetPositions,\\n        0,\\n        index (leon.adventure.targetPositions, {getTPos(idx)}, 0)\)\\n        . targetPos . \":\"\\n        . sub (\\n          leon.adventure.targetPositions,\\n          index (leon.adventure.targetPositions, {getTPos(idx)}, 0),\\n          99999\),\\n    leon.adventure.targetPositions\\)\\)\n\n{setTPos(\\n  idx,\\n  if (\\n    false == contains(leon.adventure.targetPositions, targetPos)\\n      || {getTPos(idx)} == sub (leon.adventure.targetPositions, index (leon.adventure.targetPositions, targetPos, 0) + 5, 4),\\n    targetPos,\\n    {getTPos(idx)}\\)\\)}\ncurPos -= {nextDir({getField(idx)})}\ngoto (if (\\n  {getField({posToString(x(curPos), y(curPos))})} != \"S\",\\n  innerLoop2,\\n  if (len(lootPositions) > 0, loop2, end)\\)\\)\n\nend:\nwait(0.)\};"clear room":{:import adventure_lib\n:name {package}:clear room\n\n:global int leon.adventure.maxDifficulty\n:global string leon.adventure.path\n:global string leon.adventure.targetPositions\n\n:global string leon.adventure.room_direction\n:local double difficulty\n\n#nextRoomLower if (\\n  x(adventure.roomCoords()) < 127.0 && y(adventure.roomCoords()) >= 127.0,\\n  \"R\",\\n  if (\\n    x(adventure.roomCoords()) >= 127.0 && y(adventure.roomCoords()) > 127.0,\\n    \"D\",\\n    if (\\n      x(adventure.roomCoords()) > 127.0 && y(adventure.roomCoords()) <= 127.0,\\n      \"L\",\\n      \"U\"\\)\\)\\)\n#rotateLeft(x) sub (\"LDRU\", index (\"ULDR\", {x}, 0), 1)\n#condRotateLeft(cond, x) sub (if ({cond}, \"LDRU\", \"ULDR\"), index (\"ULDR\", {x}, 0), 1)\n\nexecutesync (\"{package}:farm keys\")\n\n; We check based on current difficulty plus 1, because it's more efficient\n; that way.\ndifficulty = {cur_difficulty(1.)}\nleon.adventure.room_direction = if (\\n  difficulty == 1. && leon.adventure.room_direction != \"\",\\n  {rotateLeft(leon.adventure.room_direction)},\\n  {condRotateLeft({survivable(difficulty)}, {nextRoomLower})}\\)\n\nleon.adventure.targetPositions = sub (\\n    \"0918 0009 1809 0900\",\\n    index (\"U    L    R    D\", leon.adventure.room_direction, 0),\\n    4\\) . \":\"\n\nexecutesync (\"{package}:find loot\")\nleon.adventure.path = leon.adventure.room_direction\nexecutesync (\"{package}:follow path\")\nend:\nwait(0.)\};"farm keys":{:import adventure_lib\n:name {package}:farm keys\n\n:global string leon.adventure.path\n:global bool leon.adventure.running\n:global int leon.adventure.maxDifficulty\n\n:local double difficulty\n:local bool parity\n:local bool needs_something\n:local bool skipped\n\n:local string dir\n\n#needs_bombs adventure.bombs() < 99 && difficulty >= 80. && adventure.hasItem(\"leechSword\")\n#needs_health adventure.playerHealth() < 99 && adventure.hasItem(\"leechSword\")\n#needs_mana (adventure.mana() < 99 || {needs_armor}) && adventure.hasItem(\"manaReaver\") && adventure.hasItem(\"bookSpells\")\n#needs_keys adventure.keys() <= 10\n#needs_armor adventure.manaArmor() < adventure.playerArmor()\n#num_enemies round(difficulty * 0.1 + 3.)\n#elite_dmg d2i(floor(difficulty * 0.01 + 1.)) * (d2i(ceil(ceil(difficulty * 0.39) * 1.5)) - adventure.playerArmor())\n\ngoto (start)\n\nnext:\nparity = false == parity\nleon.adventure.path = dir\nexecutesync (\"{package}:follow path\")\nstart:\ndifficulty = {cur_difficulty(0.)}\nneeds_something = {survivable(difficulty)} && ({needs_bombs} || {needs_health} || {needs_mana} || {needs_keys})\ndir = sub (\"XU   D  L  R\", index (\" 918 90 09 189\", x(adventure.playerPos()) . y(adventure.playerPos()), 0), 1)\nskipped = contains(\"UDLR\", dir) && (\\n  (adventure.countEntities(\"Elite\") > 0) != ({needs_bombs})\\n    && (adventure.countEntities(\"Elite\") > 0 || adventure.playerHealth() + adventure.manaArmor() > 100 - d2i({num_enemies} * 1.8))\\n    || (adventure.countEntities(\"Elite\") > 0 && adventure.playerHealth() + adventure.manaArmor() <= {elite_dmg})\\n    || (parity && false == needs_something)\\)\ngotoif (keel, {needs_armor} == false || adventure.mana() < 5)\nadventure.useSpell(\"manaArmor\")\ngotoif (keel - 3, {needs_armor})\nkeel:\nexecutesync (if (skipped, \"{package}:xNOOPx\", \"{package}:kill enemies\"))\n; Update needs_something after clearing\ngoto (if (\\n  contains(\"UDLR\", dir) && leon.adventure.running && (\\n    needs_something && ({needs_bombs} || {needs_health} || {needs_mana} || {needs_keys} || {needs_armor})\\n      || parity\\n      || skipped\),\\n  next,\\n  end\\)\\)\nend:\nwait(0.)\};"find loot":{:import adventure_lib\n:name {package}:find loot\n\n:global int turbo.cycles.max\n:global int turbo.cycles\n:global bool leon.adventure.running\n:global string leon.adventure.targetPositions\n:global int leon.adventure.maxDifficulty\n\nkey.u()\nkey.j()\n\nisopen(\"arcade\")\n\nleon.adventure.maxDifficulty +=\\n  if (contains(impulse(), \"key.j\"), -1, if (contains(impulse(), \"key.u\"), 1, 0))\ngotoif (end, contains(impulse(), \"key.\"))\n\nstart:\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)\nexecutesync (\"{package}:analyze loot\")\nloop:\nexecutesync (\"{package}:find path\")\nexecutesync (\"{package}:follow path\")\nleon.adventure.targetPositions = sub (leon.adventure.targetPositions, 5, 99999)\ngotoif (loop, len(leon.adventure.targetPositions) > 0 && leon.adventure.running)\nend:\nwait(0.)\};"find path":{:import adventure_lib\n:name {package}:find path\n\n:global string leon.adventure.path\n:global string leon.adventure.targetPositions\n:global int turbo.cycles.max\n:global int turbo.cycles\n\n:local vector curPos\n:local string queue\n:local string idx\n:local string dir\n:local string path\n:local bool cantPhase\n\n#setField(index, value) lss (\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)\nleon.adventure.path = \"\"\ncantPhase = false == adventure.hasItem(\"bootsPhasing\")\\n|| 0 < max(\\n  max(\\n    max(\\n      adventure.countEntities(\"Chest\"),\\n      adventure.countEntities(\"Enemy\")\),\\n    adventure.countEntities(\"Elite\")\),\\n  adventure.countEntities(\"Mimic\")\\)\nqueue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . \"S:\"\nloop1:\ncurPos = {firstElementPos}\nidx = sub (queue, 0, 4)\n{setField(if ({getField(idx)} != \"\", \"\", idx), {firstElementDir})}\nqueue = sub (queue, 6, 99999) . if ({getField(idx)} != {firstElementDir},\\n  \"\",\\n  if (\\n    adventure.isWall(curPos + vec(0., 1.)) && cantPhase\\n      || max(x(curPos), y(curPos)) >= 18.\\n      || x(curPos) < 1.,\\n    \"\",\\n    {posToString(x(curPos), y(curPos) + 1.)} . \"U:\"\) . if (\\n    adventure.isWall(curPos + vec(0., -1.)) && cantPhase\\n      || min(x(curPos), y(curPos)) < 1.\\n      || x(curPos) >= 18.,\\n    \"\",\\n    {posToString(x(curPos), y(curPos) - 1.)} . \"D:\"\) . if (\\n    adventure.isWall(curPos + vec(1., 0.)) && cantPhase\\n      || max(x(curPos), y(curPos)) >= 18.\\n      || y(curPos) < 1.,\\n    \"\",\\n    {posToString(x(curPos) + 1., y(curPos))} . \"R:\"\) . if (\\n    adventure.isWall(curPos + vec(-1., 0.)) && cantPhase\\n      || min(x(curPos), y(curPos)) < 1.\\n      || y(curPos) >= 18.,\\n    \"\",\\n    {posToString(x(curPos) - 1., y(curPos))} . \"L:\"\\)\\)\ngoto (if (\\n  queue == \"\" || contains(idx, sub (leon.adventure.targetPositions, 0, 4)),\\n  l2start,\\n  loop1\\)\\)\n\nloop2:\nleon.adventure.path = dir . leon.adventure.path\ncurPos -= {nextDir(dir)}\nidx = {posToString(x(curPos), y(curPos))}\nl2start:\ndir = {getField(idx)}\ngotoif (loop2, dir != \"S\")\n\nexecutesync (\"{package}:refine path\")\nwait(0.0)\};"follow path":{:import adventure_lib\n:name {package}:follow path\n\n:global string leon.adventure.path\n:global bool leon.adventure.running\n\n:local int stepCount\n:local vector curPos\n:local bool waitChest\n:local vector nextMove\n\n#nextDirection sub (leon.adventure.path, stepCount, 1)\n#nextMove {nextDir({nextDirection})}\n#curEntity adventure.entityType(curPos + {nextDir({nextDirection})})\n\ngoto (start)\n\nbomb:\nadventure.placeBomb()\ngoto (move)\n\nwait:\nadventure.wait()\n\nmove:\nstepCount += 1\nstart:\ncurPos = adventure.playerPos()\nnextMove = {nextMove}\nwaitChest = contains(adventure.entityType(adventure.playerPos() + nextMove), \"Chest\")\n\nmove2:\nexecutesync (\"TE2.2:stop\")\nadventure.move(nextMove)  ; This is a no-op for invalid (0,0) moves\nexecutesync (\"TE2.2:start\")\n\nloop:\n; This uses the spacing of unused values in the index expression to be equivalent\n; to lines to skip *backward*. This is much cheaper than having a nested ternary.\n; index returns -1 for the fallthrough case. (UDLR -> move)\ngoto (if (\\n  stepCount < len(leon.adventure.path) && leon.adventure.running,\\n  if (\\n    contains(\"BW\", {nextDirection})\\n      || x(curPos) != x(adventure.playerPos())\\n      || y(curPos) != y(adventure.playerPos())\\n      || waitChest && adventure.entityType(adventure.playerPos() + nextMove) == \"\",\\n    (move - 1) - index (\"W B\", {nextDirection}, 0),\\n    move2\),\\n  end\\)\\)\n\nend:\nwait(0.)\};"init":{:import adventure_lib\n:name {package}:init\n\n:global double leon.adventure.delay\n:global string leon.adventure.path\n:global bool leon.adventure.running\n:global int leon.adventure.maxDifficulty\n:global string leon.adventure.targetPositions\n:global string leon.adventure.room_direction\n:local int maxDifficultyInit\n\nkey.r()\nkey.i()\n\nisopen(\"arcade\")\n\nmaxDifficultyInit = 81\nleon.adventure.maxDifficulty = if (\\n  contains(impulse(), \"key.i\") || leon.adventure.maxDifficulty == 0,\\n  maxDifficultyInit,\\n  leon.adventure.maxDifficulty\\)\n\ngoto (if (\\n  contains(impulse(), \"key.i\"),\\n  end,\\n  if (leon.adventure.running, stop, start)\\)\\)\nstart:\nexecutesync (\"TE2.2:start\")\ngis(\"<size=0>leon.adventure\",0)\nleon.adventure.running = true\nleon.adventure.path = \"\"\nleon.adventure.targetPositions = \"\"\nleon.adventure.room_direction = \"\"\ngss(\"---Stop hiding---\", \"</size=0>\")\nloop:\nexecutesync (\"{package}:clear room\")\nleon.adventure.maxDifficulty = leon.adventure.maxDifficulty + if (\\n  {cur_difficulty(0.)} >= i2d(leon.adventure.maxDifficulty)\\n    && adventure.isCompleted(adventure.roomCoords()),\\n  2,\\n  0\\)\ngotoif (loop, leon.adventure.running)\nexecutesync (\"TE2.2:stop\")\nstop:\nleon.adventure.running = false\nend:\nwait(0.)\};"kill enemies":{:import adventure_lib\n:name {package}:kill enemies\n\n#enemyInDir(x, y) adventure.isEnemy(adventure.playerPos() + vec({x},{y}))\n#enemyDirection if ({enemyInDir(0., 1.)}, vec(0., 1.),\\n    if ({enemyInDir(1., 0.)}, vec(1., 0.),\\n    if ({enemyInDir(0., -1.)}, vec(0., -1.),\\n    if ({enemyInDir(-1., 0.)}, vec(-1., 0.), vec(0., 0.)))))\n#anyEnemies {enemyInDir(0., 1.)} || {enemyInDir(0., -1.)} || {enemyInDir(1., 0.)} || {enemyInDir(-1., 0.)}\n\nkey.k()\n\nisopen(\"arcade\")\n\ngoto (if (contains(impulse(), \"key.\"), turbostart, loop))\n\nwait:\nadventure.wait()\n\nattack:\nexecutesync (\"TE2.2:stop\")\nadventure.move({enemyDirection})\n\nturbostart:\nexecutesync (\"TE2.2:start\")\n\nloop:\ngoto (if (\\n  {anyEnemies},\\n  attack,\\n  if (\\n    max(max(adventure.countEntities(\"Enemy\"), adventure.countEntities(\"Elite\")), adventure.countEntities(\"Mimic\")) > 0,\\n    wait,\\n    if (contains(impulse(), \"key.\"), stop, end)\\)\\)\\)\nstop:\nexecutesync (\"TE2.2:stop\")\nend:\nwait(0.)\};"refine path":{:import adventure_lib\n:name {package}:refine path\n\n:global string leon.adventure.path\n\n:local vector curPos\n:local int stepCount\n\n#curDirection sub (leon.adventure.path, stepCount, 1)\n#insert(st,i,val) sub ({st},0,{i}) . ({val}) . sub ({st},{i},99999)\n#escapeDirection if (\\n  adventure.entityType(curPos + vec(0., 1.)) == \"\"\\n    && adventure.entityType(curPos + vec(0., 2.)) == \"\"\\n    && false == adventure.isWall(curPos + vec(0., 1.))\\n    && y(curPos) < 17.,\\n  \"BUUWDD\",\\n  if (\\n    adventure.entityType(curPos + vec(0., -1.)) == \"\"\\n      && adventure.entityType(curPos + vec(0., -2.)) == \"\"\\n      && false == adventure.isWall(curPos + vec(0., -1.))\\n      && y(curPos) > 1.,\\n    \"BDDWUU\",\\n    if (\\n      adventure.entityType(curPos + vec(-1., 0.)) == \"\"\\n        && adventure.entityType(curPos + vec(-2., 0.)) == \"\"\\n        && false == adventure.isWall(curPos + vec(-1., 0.))\\n        && x(curPos) > 1.,\\n      \"BLLWRR\",\\n      \"BRRWLL\"\)\\)\\)\n\ncurPos = adventure.playerPos()\ngoto (start)\n\nrock:\nleon.adventure.path = {insert(\\n  leon.adventure.path,\\n  stepCount,\\n  if (adventure.hasItem(\"eodArmor\"), \"BWWW\", {escapeDirection})\\)}\nstepCount += if (adventure.hasItem(\"eodArmor\"), 4, 6)\n\nnextTile:\ncurPos += {nextDir({curDirection})}\nstepCount += 1\n\nstart:\ngoto (if (\\n  stepCount >= len(leon.adventure.path),\\n  end,\\n  if (\\n    adventure.entityType(curPos + {nextDir({curDirection})}) != \"Rock\" || adventure.hasItem(\"hammer\"),\\n    nextTile,\\n    rock\\)\\)\\)\nend:\nwait(0.)\};"adventure_lib":{#package Adventure v3.2\n\n#strToVec(str) vec(s2d(sub ({str}, 0, 2), -1.), s2d(sub ({str}, 2, 2), -1.))\n; converts the string in memory into a usable vector\n\n#posToString(x, y) sub (d2s(({x}) + 200.), 1, 2) . sub (d2s(({y}) + 200.), 1, 2)\n; converts the specified position into a string \n\n#firstElementPos {strToVec(queue)}\n; determines what is the first element of the specified position\n\n#firstElementDir sub (queue, 4, 1)\n; determines the direction of the first element in the queue\n\n#cur_difficulty(offset) (max(254. - x(adventure.roomCoords()), x(adventure.roomCoords())) + max(254. - y(adventure.roomCoords()), y(adventure.roomCoords())) + ({offset} - 254.))\n;\n\n#survivable(difficulty) (\\n  ceil(i2d(adventure.playerAttack()) * if (adventure.hasItem(\"impaler\"), 1.1, 1.)) >=\\n    round({difficulty} * 0.38 + 1.) + round({difficulty} * 0.08)\\n    || i2d(adventure.playerArmor()) >= ceil({difficulty} * 0.39)\\) && i2d(leon.adventure.maxDifficulty) >= {difficulty}\\n  && (adventure.hasItem(\"lantern\") || {difficulty} < 100.)\n\n#nextX(d) s2d(sub (\"X 0 0 1-1\", index (\" U D R L\", {d}, 0), 2), 0.)\n;\n\n#nextY(d) s2d(sub (\"X 1-1 0 0\", index (\" U D R L\", {d}, 0), 2), 0.)\n;\n\n#nextDir(d) vec({nextX({d})}, {nextY({d})})\};\};