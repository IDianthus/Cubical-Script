{"workspaces":{"d0sboots Adventure":[["adventure_lib","#package Adventure v3.0\n\n#abs(x) ( ( ( {x} ) ^ 2.0 ) ^ 0.5 )\n\n#goRight ( curPos + 1.0 )\n#goLeft ( curPos - 1.0 )\n#goUp ( curPos + 19.0 )\n#goDown ( curPos - 19.0 )\n\n#xMove(d) if( {d} == \"L\", -1.0, ternary.double( {d} == \"R\", 1.0, 0.0 ) )\n#yMove(d) if( {d} == \"U\", 1.0, ternary.double( {d} == \"D\", -1.0, 0.0 ) )\n#move(d) vec( {xMove({d})}, {yMove({d})} )\n\n#posToVec(x) vec( ( {x} ) % 19.0, floor( ( {x} ) / 19.0 ) )\n#posToString(p) sub( d2s( ( {p} ) + 1000.0 ), 1, 3)\n#firstElementPos s2d( sub( queue, 0, 3 ), -1.0 )\n#firstElementDir sub( queue, 3, 1 )\n\n#nextField(d) ( curPos + s2d ( \\\n\tsub( \"019 -19 -01 001\", index( \"U   D   L   R\", {d}, 0 ), 3 ), 0.0 ) \\\n\t)\n#nextFieldInverse(d) ( curPos + s2d ( \\\n\tsub( \"-19 019 001 -01\", index(\"U   D   L   R\", {d}, 0), 3), 0.0 )\\\n\t)\n#replace( st, i, val, valLen ) sub( {st}, 0, {i} ) . \\\n    {val} . \\\n    sub( {st}, ( {i} ) + ( {valLen} ), 99999 )\n#pop queue = sub( queue, 5, 99999 )\n#cur_difficulty {abs( x( adventure.roomCoords() ) + y( adventure.roomCoords() ) - 254.0 )}\n\n"],["init",":import adventure_lib\n\n:name {package}:init\n\n:global double leon.adventure.delay\n:global double leon.adventure.target_pos\n\n:global string leon.adventure.path\n:global string leon.adventure.targetPositions\n:global string leon.adventure.room_direction\n\n:global int leon.adventure.running\n:global int leon.adventure.maxDifficulty\n\n:local int maxDifficultyInit\n\nkey.r()\nkey.i()\n\nisopen( \"arcade\" )\n\n\nmaxDifficultyInit = 81\nleon.adventure.maxDifficulty = ternary.int( impulse() == \"key.i\", \\\n\tmaxDifficultyInit, \\\n\tternary.int( leon.adventure.maxDifficulty == 0,\\\n\t\tmaxDifficultyInit, \\\n\t\tleon.adventure.maxDifficulty\\\n\t\t) \\\n\t)\n\ngoto( ternary.int( impulse() == \"key.i\", \\\n\tend, \\\n\tternary.int( leon.adventure.running != 0, \\\n\t\tstop, \\\n\t\tstart ) \\\n    ) \\\n)\n\nstart:\nexecutesync( \"turbo start\" )\ngis( \"<size=0>leon.adventure\", 0)\nleon.adventure.running = 1\nleon.adventure.target_pos = 0.0\nleon.adventure.path = \"\"\nleon.adventure.targetPositions = \"\"\nleon.adventure.room_direction = \"\"\ngss( \"---Stop hiding---\", \"</size=0>\")\n\nloop:\nexecutesync( \"{package}:clear room\" )\nleon.adventure.maxDifficulty = leon.adventure.maxDifficulty + if( \\\n\t{cur_difficulty} >= i2d( leon.adventure.maxDifficulty ) \\\n\t&& adventure.isCompleted( adventure.roomCoords() ), \\\n\t\t2, \\\n\t\t0 \\\n\t)\ngotoif( loop, leon.adventure.running == 1 )\nexecutesync( \"turbo stop\" )\n\nstop:\nleon.adventure.running = 0\n\nend:\nwait( 0.0 )\n\n"],["clear room",":import adventure_lib\n\n:name {package}:clear room\n\n:global int leon.adventure.maxDifficulty\n\n:global string leon.adventure.path\n:global string leon.adventure.targetPositions\n\n:global string leon.adventure.room_direction\n\n#nextRoomLower ternary.string( \\\n\tx( adventure.roomCoords() ) < 127.0 && y( adventure.roomCoords() ) >= 127.0, \"R\", if( \\\n\tx( adventure.roomCoords() ) >= 127.0 && y( adventure.roomCoords() ) > 127.0, \"D\", if( \\\n\tx( adventure.roomCoords() ) > 127.0 && y( adventure.roomCoords() ) <= 127.0, \"L\", \\\n\t\"U\" \\\n\t))\\\n\t)\n#rotateLeft(x) sub( \"LDRU\", index( \"ULDR\", {x}, 0 ), 1 )\n\nexecutesync( \"{package}:kill enemies\" )\nexecutesync( \"{package}:farm keys\" )\n\nleon.adventure.room_direction = if( \\\n\t{cur_difficulty} == 0.0 && len( leon.adventure.room_direction ) > 0, \\\n\t\t{rotateLeft( leon.adventure.room_direction )}, \\\n\t\tif( \\\n\t\t\t( i2d( adventure.playerAttack() ) >= round( ( {cur_difficulty} + 1.0 ) * 0.38 + 1.0 ) + \\\n\t\t\t\tround( ( {cur_difficulty} + 1.0 ) * 0.08 ) \\\n\t\t\t|| i2d( adventure.playerArmor() ) >= ceil( ( {cur_difficulty} + 1.0 ) * 0.39 ) ) \\\n\t\t\t&& i2d( leon.adventure.maxDifficulty ) >= ( {cur_difficulty} + 1.0 ), \\\n\t\t\t\t{rotateLeft( {nextRoomLower} )}, \\\n\t\t\t\t{nextRoomLower} \\\n\t\t) \\\n\t)\n\nleon.adventure.targetPositions = sub(\\\n\t\"351 171 189 009\", index( \"U   L   R   D\", leon.adventure.room_direction, 0), 3\\\n\t) . \":\"\n\nexecutesync( \"{package}:find loot\" )\nleon.adventure.path = leon.adventure.room_direction\nexecutesync( \"{package}:follow path\" )\n\nend:\nwait(0.0)\n\n"],["follow path",":import adventure_lib\n\n:name {package}:follow path\n\n:global string leon.adventure.path\n:global int leon.adventure.running\n\n:local int stepCount\n:local double curPos\n:local string status\n\n#nextDirection sub( leon.adventure.path, stepCount, 1 )\n#nextMove {move({nextDirection})}\n\n#playerPos x( adventure.playerPos() ) + 19.0 * y( adventure.playerPos() )\n#status adventure.entityType( {posToVec({nextField({nextDirection})})} )\n\nstepCount = -1\n\nloop:\nstepCount = stepCount + 1\ngoto( ternary.int( stepCount >= len( leon.adventure.path ) || leon.adventure.running != 1, end, \\\n\tternary.int( {nextDirection} == \"B\", bomb, ternary.int( {nextDirection} == \"W\", wait, move ))) \\\n    )\n\nmove:\ncurPos = {playerPos}\nstatus = {status}\n\nmove2:\nexecutesync( \"turbo stop\" )\nadventure.move( {nextMove} )\nexecutesync( \"turbo start\" )\ngoto( ternary.int( curPos != {playerPos} || status != {status}, loop, move2 ) )\n\nbomb:\nexecutesync( \"turbo stop\" )\nadventure.placeBomb()\nexecutesync( \"turbo start\" )\ngoto( loop )\n\nwait:\nexecutesync( \"turbo stop\" )\nadventure.wait()\nexecutesync( \"turbo start\" )\ngoto( loop )\n\nend:\nwait( 0.0 )\n\n"],["find path",":import adventure_lib\n\n:name {package}:find path\n\n:global int turbo.cycles.max\n:global int turbo.cycles\n\n:global string leon.adventure.path\n:global double leon.adventure.target_pos\n\n:local double curPos\n\n:local string queue\n:local string field\n:local string path\n\n#distance( x, y ) ( {x} % 19.0 ) - ( {y} % 19.0 ) + floor( {x} / 19.0 ) - floor( {y} / 19.0 )\n\nstart:\nturbo.cycles.max = max( turbo.cycles.max, turbo.cycles + 4000 )\nqueue = {posToString( x( adventure.playerPos() ) + 19.0 * y ( adventure.playerPos() ) )} . \"S:\"\nfield = \"{lua(return string.rep( \"0\", 362 ) )}\"\n\nloop1:\ncurPos = {firstElementPos}\nfield = {replace( field, d2i( curPos ), {firstElementDir}, 1 )}\n{pop}\n\nqueue = queue . if( \\\n\t\tadventure.isWall( {posToVec( {goUp} )} ) == false && \\\n\t\tcontains( queue, {posToString( {goUp} )} ) == false && \\\n\t\t{goUp} < 361.0 && \\\n\t\tsub( field, d2i( {goUp} ), 1) == \"0\", \\\n\t\t\tconcat( {posToString( {goUp} )}, \"U:\" ), \\\n            \"\" \\\n\t) . if( \\\n\t\tadventure.isWall( {posToVec( {goDown} )} ) == false && \\\n\t\tcontains( queue, {posToString( {goDown} )} ) == false && \\\n\t\t{goDown} >= 0.0 &&\\\n\t\tsub( field, d2i( {goDown} ), 1) == \"0\", \\\n\t\t\t{posToString( {goDown} )} . \"D:\", \\\n\t\t\t\"\" \\\n\t) . if( \\\n    \tadventure.isWall( {posToVec( {goRight} )} ) == false && \\\n\t\tcontains( queue, {posToString( {goRight} )} ) == false && \\\n\t\tsub( field, d2i( {goRight} ), 1) == \"0\"&&\\\n\t\t{distance({goRight},curPos)} <= 1.0, \\\n\t\t\t{posToString( {goRight} )} . \"R:\", \\\n\t\t\t\"\"\\\n\t) . if( \\\n\t\tadventure.isWall( {posToVec( {goLeft} )} ) == false && \\\n\t\tcontains( queue, {posToString( {goLeft} )} ) == false && \\\n\t\tsub( field, d2i( {goLeft} ), 1) == \"0\" &&\\\n\t\t{distance( {goLeft}, curPos )} <= 1.0, \\\n\t\t\t{posToString( {goLeft} )} . \"L:\", \\\n\t\t\t\"\"\\\n\t)\n\ngotoif( loop1, len( queue ) > 0 && curPos != leon.adventure.target_pos )\n\nloop2:\npath = sub( field, d2i( curPos ), 1) . path\ncurPos = if( sub( path, 0, 1) == \"U\", {goDown}, if( sub( path, 0, 1) == \"D\", {goUp}, if( \\\n\tsub( path, 0, 1) == \"R\", {goLeft}, if( sub( path, 0, 1) == \"L\", {goRight}, curPos ) ) ) \\\n    )\ngotoif( loop2, sub( field, d2i( curPos ), 1) != \"S\" )\nleon.adventure.path = if( path == \"S\", \"\", path)\nexecutesync( \"{package}:refine path\" )\n\nend:\nwait(0.0)\n\n"],["refine path",":import adventure_lib\n\n:name {package}:refine path\n\n:global string leon.adventure.path\n\n:local string path\n:local double curPos\n:local int stepCount\n\n#nextVec(d) {posToVec( curPos )} + vec( \\\n\ts2d( sub( \"1102\", index( \"UDLR\", {d}, 0), 1), 0.0), \\\n\ts2d( sub( \"2011\", index( \"UDLR\", {d}, 0), 1), 0.0) \\\n\t) - vec( 1.0, 1.0 )\n#curDirection sub( path, stepCount, 1)\n\n#insert( st, i, val) sub( {st}, 0, {i} ) . ( {val} ) . sub( {st}, {i}, 99999)\n\n#inverse(d) ternary.string( {d} == \"U\", \\\n\t\"D\", \\\n\tternary.string( {d} == \"D\", \\\n\t\t\"U\", \\\n\t\tternary.string( {d} == \"R\", \\\n\t\t\t\"L\", \\\n\t\t\t\"R\" \\\n\t\t\t)\\\n\t\t)\\\n\t)\n\n#getEntity(pos) adventure.entityType( {posToVec( {pos} )} )\n#getCurrentEntity adventure.entityType( {nextVec( {curDirection} )} )\n#escapeDirection if( \\\n\t\t\t{getEntity( {goUp} )} == \"\" && \\\n\t\t\t{getEntity( curPos + 19.0 * 2.0 )} == \"\" && \\\n\t\t\tadventure.isWall( {posToVec( {goUp} )} ) == false &&\\\n\t\t\t{goUp} != 351.0, \\\n            \t\"BUUWDD\", \\\n\t\t\t\tif( \\\n\t\t\t\t{getEntity({goDown})}==\"\" && \\\n\t\t\t\t{getEntity(curPos - 19. * 2.)} == \"\" && \\\n\t\t\t\tadventure.isWall({posToVec( {goDown} )} ) == false && \\\n\t\t\t\t{goDown} != 9.0, \\\n\t\t\t\t\t\"BDDWUU\", \\\n\t\t\t\t\tif(\\\n\t\t\t\t\t{getEntity({goLeft})} == \"\" && \\\n\t\t\t\t\t{getEntity(curPos - 2.)} == \"\" && \\\n\t\t\t\t\tadventure.isWall({posToVec({goLeft})}) == false && \\\n\t\t\t\t\t{goLeft} != 171., \\\n\t\t\t\t\t\t\"BLLWRR\", \\\n\t\t\t\t\t\t\"BRRWLL\" \\\n\t\t\t\t\t) \\\n\t\t\t\t) \\\n\t\t\t)\n\nstart:\ncurPos = x( adventure.playerPos() ) + 19.0 * y( adventure.playerPos() )\nstepCount = 0\npath = leon.adventure.path\n\nloop:\ngoto( if( stepCount >= len( path ), end, if( {getCurrentEntity} == \"Door\", door, \\\n\tif( {getCurrentEntity} == \"Rock\", if( adventure.hasItem(\"hammer\"), door, rock ), nextTile)) \\\n\t))\n\nrock:\npath = {insert( path, stepCount, if( adventure.hasItem( \"eodArmor\" ), \"BWWW\", {escapeDirection} ) )}\nstepCount = stepCount + if( adventure.hasItem( \"eodArmor\" ), 4, 6)\ngoto( nextTile )\n\ndoor:\npath = {insert( path, stepCount, {curDirection} )}\nstepCount = stepCount + 1\n\nnextTile:\ncurPos = {nextField( {curDirection} )}\nstepCount = stepCount + 1\ngoto( loop )\n\nend:\nleon.adventure.path = path\nwait( 0.0 )\n\n"],["kill enemies",":import adventure_lib\n\n:name {package}:kill enemies\n\n#enemies_alive ({lua( \\\n\tlocal positions = {} \\\n\tlocal counter = 1 \\\n\tfor x = 1, 17, 1 do \\\n\t\tfor y = 1, 17, 1 do \\\n\t\t\tif not( x % 2 == 0 and y % 2 == 0 ) then \\\n\t\t\t\tpositions[ counter ] = \"adventure.isEnemy( vec( \"..x..\".,\"..y..\".) )\" \\\n\t\t\t\tcounter = counter + 1 \\\n\t\t\tend \\\n\t\tend \\\n\tend \\\n\tpositions[ counter ] = \"adventure.isEnemy( vec( 0.0, 9.0 ) )\" \\\n\tpositions[ counter + 1 ] = \"adventure.isEnemy( vec( 9.0, 0.0 ) )\" \\\n\tpositions[ counter + 2 ] = \"adventure.isEnemy( vec( 9.0, 18.0 ) )\" \\\n\tpositions[ counter + 3 ] = \"adventure.isEnemy( vec( 18.0, 9.0 ) )\" \\\n\treturn table.concat( positions, \"||\") )} )\n\n#enemyInDir( x, y ) adventure.isEnemy( adventure.playerPos() + vec( {x}, {y} ) )\n#enemyDirection if( {enemyInDir( 0.0, 1.0 )}, \"U\", if( \\\n\t{enemyInDir( 1.0, 0.0 )}, \"R\", if( \\\n    {enemyInDir( 0.0, -1.0 )}, \"D\", if( \\\n    {enemyInDir( -1.0, 0.0 )}, \"L\", \"W\" ))) \\\n    )\n\nkey.k()\n\nisopen(\"arcade\")\n\ngotoif( start, impulse() != \"key.k\" )\nexecutesync( \"turbo start\" )\n\nstart:\ngoto( ternary.int( {enemies_alive}, wait, ternary.int( impulse() == \"key.k\", stop, end ) ) )\n\nwait:\nexecutesync( \"turbo stop\" )\nadventure.wait()\nexecutesync( \"turbo start\" )\ngotoif( wait, {enemyDirection} == \"W\" )\n\nattack:\nexecutesync( \"turbo stop\" )\nadventure.move( {move( {enemyDirection} )} )\nexecutesync( \"turbo start\" )\ngoto( ternary.int( {enemyDirection} != \"W\", attack, start ) )\n\nstop:\nexecutesync( \"turbo stop\" )\n\nend:\nwait( 0.0 )\n\n"],["find loot",":import adventure_lib\n:name {package}:find loot\n\n:global int turbo.cycles.max\n:global int turbo.cycles\n\n:global string leon.adventure.targetPositions\n:global double leon.adventure.target_pos\n:global int leon.adventure.running\n:global int leon.adventure.maxDifficulty\n\nkey.u()\nkey.j()\n\nisopen(\"arcade\")\n\nleon.adventure.maxDifficulty = leon.adventure.maxDifficulty + if( \\\n\timpulse() == \"key.j\", -1, if( impulse() == \"key.u\", 1, 0 ) \\\n\t)\ngotoif( end, contains( impulse(), \"key.\" ) )\n\nstart:\nturbo.cycles.max = max( turbo.cycles.max, turbo.cycles + 4000 )\nexecutesync( \"{package}:analyze loot\" )\n\nloop:\nleon.adventure.target_pos = s2d( sub( leon.adventure.targetPositions, 0, 3 ), 0.0 )\nleon.adventure.targetPositions = sub( leon.adventure.targetPositions, 4, 99999 )\nexecutesync( \"{package}:find path\" )\nexecutesync( \"{package}:follow path\" )\ngotoif( loop, len( leon.adventure.targetPositions ) > 0 && leon.adventure.running > 0 )\n\nend:\nwait( 0.0 )\n\n"],["farm keys",":import adventure_lib\n\n:name {package}:farm keys\n\n:global string leon.adventure.path\n:global int leon.adventure.running\n\n:local int curPos\n\nstart:\ncurPos = d2i( x( adventure.playerPos() ) ) + a.i( 19, \"*\", d2i( y( adventure.playerPos() ) ) )\ngotoif( end, \\\n\tadventure.keys() > 10 || ( \\\n\t\t( curPos != 9 && curPos != 189 ) && ( curPos != 171 && curPos != 351 ) \\\n\t\t) || leon.adventure.running != 1 \\\n\t)\nleon.adventure.path = \\\n\tternary.string( curPos == 9, \"D\", \\\n\t\tternary.string( curPos == 171, \"L\", \\\n\t\t\tternary.string( curPos == 189, \"R\", \"U\" ) \\\n\t\t) \\\n\t)\nexecutesync( \"leon.adventure:follow path\" )\nexecutesync( \"leon.adventure:kill enemies\" )\nleon.adventure.path = \\\n\tternary.string( curPos == 9, \"U\", \\\n\t\tternary.string( curPos == 171, \"R\", \\\n\t\t\tternary.string( curPos == 189, \"L\", \"D\" ) \\\n\t\t) \\\n\t)\nexecutesync( \"leon.adventure:follow path\" )\nexecutesync( \"leon.adventure:kill enemies\" )\ngoto( start )\n\nend:\nwait( 0.0 )\n\n"],["analyze loot",":import adventure_lib\n\n:name {package}:analyze loot\n\n:global string leon.adventure.targetPositions\n\n:local string field\n:local string queue\n:local string insertPosition\n:local string lootPositions\n:local double curPos\n:local double targetPos\n\n#toQueueElement( pos, dir ) {posToString( {pos} )} . {dir} . \":\"\n#enqueue( pos, dir ) queue = queue . {toQueueElement( {pos}, {dir} )}\n\n{enqueue( x( adventure.playerPos() ) + 19.0 * y( adventure.playerPos() ), \"S\" )}\nfield = \"{lua( return string.rep( \"0000\", 362 ) )}\"\n\nloop1:\ncurPos = {firstElementPos}\nfield = {replace( field, d2i( curPos ) * 4, {firstElementDir}, 1 )}\n{pop}\nqueue = queue . if( \\\n\t\tadventure.isWall( {posToVec( {goUp} )} ) == false && \\\n\t\tcontains( queue, {posToString( {goUp} )} ) == false && \\\n\t\t{goUp} < 361.0 && \\\n\t\tsub( field, d2i( {goUp} ) * 4, 1 ) == \"0\" ,\\\n\t\t\t{posToString( {goUp} )} . \"U:\", \\\n\t\t\t\"\" \\\n\t\t) . if( \\\n\t\t\tadventure.isWall( {posToVec( {goDown} )} ) == false && \\\n\t\t\tcontains( queue, {posToString( {goDown} )} ) == false && \\\n\t\t\t{goDown} >= 0.0 && \\\n\t\t\tsub( field, d2i( {goDown} ) * 4, 1 ) == \"0\" , \\\n\t\t\t\t{posToString( {goDown} )} . \"D:\", \\\n\t\t\t\t\"\" \\\n\t\t) . if( \\\n\t\t\tadventure.isWall( {posToVec( {goRight} )} ) == false && \\\n\t\t\tcontains( queue, {posToString( {goRight} )} ) == false && \\\n\t\t\tsub( field, d2i( {goRight} ) * 4, 1 ) == \"0\" && \\\n\t\t\tfloor( {goRight} / 19.0 ) == floor( curPos / 19.0 ), \\\n\t\t\t\t{posToString( {goRight} )} . \"R:\", \\\n\t\t\t\t\"\" \\\n\t\t) . if( \\\n\t\t\tadventure.isWall( {posToVec( {goLeft} )} ) == false && \\\n\t\t\tcontains( queue, {posToString( {goLeft} )} ) == false && \\\n\t\t\tsub( field, d2i( {goLeft} ) * 4, 1 ) == \"0\" && \\\n\t\t\tfloor( {goLeft} / 19.0 ) == floor( curPos / 19.0 ), \\\n\t\t\t\t{posToString( {goLeft} )} . \"L:\", \\\n\t\t\t\t\"\" \\\n\t\t)\nlootPositions = if( adventure.entityType( {posToVec( curPos )} ) == \"Chest\", \\\n\t\t{posToString(curPos)} . \":\",\\\n\t\t\"\" \\\n\t) . lootPositions\ngotoif( loop1, len( queue ) > 0 )\nlootPositions = leon.adventure.targetPositions . lootPositions\n\nloop2:\ntargetPos = s2d( sub( lootPositions, 0, 3 ), 0.0 )\ncurPos = targetPos\nlootPositions = sub( lootPositions, 4, 99999 )\n\ninnerLoop2:\nleon.adventure.targetPositions = if( \\\n\t\tsub( field, d2i( {nextFieldInverse( sub( field, d2i( curPos ) * 4, 1 ) )} ) * 4, 1 ) == \"S\" \\\n\t\t&& contains( leon.adventure.targetPositions, {posToString( targetPos )} ), \\\n\t\t\t{posToString( targetPos )} . \":\" . leon.adventure.targetPositions, \\\n\t\t\tif( \\\n\t\t\t\tcontains( leon.adventure.targetPositions, {posToString( targetPos )} ) == false && \\\n\t\t\t\tsub( field, d2i( curPos ) * 4 + 1, 3 ) != \"000\", \\\n\t\t\t\t\tsub( leon.adventure.targetPositions, \\\n\t\t\t\t\t\t0, \\\n\t\t\t\t\t\tindex( leon.adventure.targetPositions, \\\n\t\t\t\t\t\t\tsub( field, d2i( curPos ) * 4 + 1, 3 ), 0 ) \\\n\t\t\t\t\t) . {posToString( targetPos )} . \":\" . sub( \\\n\t\t\t\t\t\tleon.adventure.targetPositions, \\\n\t\t\t\t\t\tindex( leon.adventure.targetPositions, \\\n\t\t\t\t\t\t\tsub( field, d2i( curPos ) * 4 + 1, 3), \\\n\t\t\t\t\t\t\t0), \\\n\t\t\t\t\t\t99999 \\\n\t\t\t\t\t\t), \\\n\t\t\t\t\tleon.adventure.targetPositions \\\n\t\t\t) \\\n\t\t)\nfield = if( contains( leon.adventure.targetPositions, {posToString( targetPos )} ) == false \\\n\t\t|| len( leon.adventure.targetPositions ) <= 4 \\\n        || sub( field, d2i( curPos ) * 4 + 1, 3 ) == sub( leon.adventure.targetPositions, \\\n\t\t\tindex( leon.adventure.targetPositions, {posToString( targetPos )}, 0 ) + 4, 3 \\\n\t\t\t), \\\n\t\t{replace( field, d2i( curPos ) * 4 + 1, {posToString( targetPos )}, 3 )}, \\\n\t\tfield \\\n\t)\ncurPos = {nextFieldInverse( sub( field, d2i( curPos ) * 4, 1 ) )}\ngoto( if( sub( field, d2i( curPos ) * 4, 1 ) != \"S\", innerLoop2, \\\n\tif( len( lootPositions ) > 0, loop2, end ) ) \\\n\t)\n\nend:\nwait( 0.0 )\n\n"]]}}