{"Adventure":{"analyze loot":{:import adventure_lib\n:name {package}:analyze loot\n\n:global string leon.adventure.targetPositions\n\n:local string queue\n:local string idx\n:local vector curPos\n:local string targetPos\n:local string lootPositions\n\n#setField(index, value) lss(\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n#setTPos(index, value) lss(\"_t\" . {index}, {value})\n#getTPos(index) lsg(\"_t\" . {index})\n\nqueue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . \"S:\"\n\n\c; On the first entry of this loop, the junk entry \"_f\" will be set to \"S\".\n\c; This has no effect.\n\c; In general, lootPositions, queue and setField are protected so that if the field\n\c; has already been set, we won't take action again.\nloop1:\ncurPos = {firstElementPos}\nidx = sub(queue, 0, 4)\nlootPositions = if(\\n  {getField(idx)} == \"\"\\n	 && contains(adventure.entityType(curPos), \"Chest\"),\\n  {posToString(x(curPos), y(curPos))} . \":\",\\n  \"\") . lootPositions\n{setField(if({getField(idx)} != \"\", \"\", idx), {firstElementDir})}\nqueue = sub(queue, 6, 99999) . if({getField(idx)} != {firstElementDir},\\n  \"\",\\n  if(\\n	 adventure.isWall(curPos + vec(0., 1.)) || y(curPos) >= 18.,\\n	 \"\",\\n	 {posToString(x(curPos), y(curPos) + 1.)} . \"U:\"\\n  ) . if(\\n	 adventure.isWall(curPos + vec(0., -1.)) || y(curPos) < 1.,\\n	 \"\",\\n	 {posToString(x(curPos), y(curPos) - 1.)} . \"D:\"\\n  ) . if(\\n	 adventure.isWall(curPos + vec(1., 0.)) || x(curPos) >= 18.,\\n	 \"\",\\n	 {posToString(x(curPos) + 1., y(curPos))} . \"R:\"\\n  ) . if(\\n	 adventure.isWall(curPos + vec(-1., 0.)) || x(curPos) < 1.,\\n	 \"\",\\n	 {posToString(x(curPos) - 1., y(curPos))} . \"L:\"\\n  )\\n)\ngotoif(loop1, queue != \"\")\n\ncontinue:\nlootPositions = leon.adventure.targetPositions . lootPositions\n\nloop2:\ntargetPos = sub(lootPositions, 0, 4)\ncurPos = {strToVec(targetPos)}\nlootPositions = sub(lootPositions, 5, 99999)\n\ninnerLoop2:\nidx = {posToString(x(curPos), y(curPos))}\nleon.adventure.targetPositions = if(\\n  {getField({posToString(\\n	 x(curPos) - {nextX({getField(idx)})},\\n	 y(curPos) - {nextY({getField(idx)})}\\n  )})} == \"S\"\\n	 && false == contains(leon.adventure.targetPositions, targetPos),\\n  targetPos . \":\" . leon.adventure.targetPositions,\\n  if(\\n	 false == contains(leon.adventure.targetPositions, targetPos) \\n		&& {getTPos(idx)} != \"\",\\n		sub(\\n		  leon.adventure.targetPositions,\\n		  0,\\n		  index(leon.adventure.targetPositions, {getTPos(idx)}, 0)\\n		)\\n		  . targetPos . \":\"\\n		  . sub(\\n			 leon.adventure.targetPositions,\\n			 index(leon.adventure.targetPositions, {getTPos(idx)}, 0),\\n			 99999\\n		  ),\\n	 leon.adventure.targetPositions\\n  )\\n)\n\n{setTPos(\\n  idx,\\n  if(\\n	 false == contains(leon.adventure.targetPositions, targetPos)\\n		|| {getTPos(idx)} == sub(leon.adventure.targetPositions, index(leon.adventure.targetPositions, targetPos, 0) + 5, 4),\\n	 targetPos,\\n	 {getTPos(idx)}\\n  )\\n)}\ncurPos -= {nextDir({getField(idx)})}\ngoto(if(\\n  {getField({posToString(x(curPos), y(curPos))})} != \"S\",\\n  innerLoop2,\\n  if(len(lootPositions) > 0, loop2, end)\\n))\n\nend:\nwait(0.)\};"clear room":{:import adventure_lib\n:name {package}:clear room\n\n:global int leon.adventure.maxDifficulty\n:global string leon.adventure.path\n:global string leon.adventure.targetPositions\n\n:global string leon.adventure.room_direction\n:local double difficulty\n\n#nextRoomLower if(\\n  x(adventure.roomCoords()) < 127.0 && y(adventure.roomCoords()) >= 127.0,\\n  \"R\",\\n  if(\\n	 x(adventure.roomCoords()) >= 127.0 && y(adventure.roomCoords()) > 127.0,\\n	 \"D\",\\n	 if(\\n		x(adventure.roomCoords()) > 127.0 && y(adventure.roomCoords()) <= 127.0,\\n		\"L\",\\n		\"U\" \\n	 )\\n  )\\n)\n#rotateLeft(x) sub(\"LDRU\", index(\"ULDR\", {x}, 0), 1)\n#condRotateLeft(cond, x) sub(if({cond}, \"LDRU\", \"ULDR\"), index(\"ULDR\", {x}, 0), 1)\n\nexecutesync(\"{package}:farm keys\")\n\n\c; We check based on current difficulty plus 1, because it's more efficient\n\c; that way.\ndifficulty = {cur_difficulty(1.)}\nleon.adventure.room_direction = if(\\n  difficulty == 1. && leon.adventure.room_direction != \"\",\\n  {rotateLeft(leon.adventure.room_direction)},\\n  {condRotateLeft({survivable(difficulty)}, {nextRoomLower})}\\n)\n\nleon.adventure.targetPositions = sub(\\n	 \"0918 0009 1809 0900\",\\n	 index(\"U	 L	 R	 D\", leon.adventure.room_direction, 0),\\n	 4\\n) . \":\"\n\nexecutesync(\"{package}:find loot\")\nleon.adventure.path = leon.adventure.room_direction\nexecutesync(\"{package}:follow path\")\nend:\nwait(0.)\};"farm keys":{:import adventure_lib\n:name {package}:farm keys\n\n:global string leon.adventure.path\n:global bool leon.adventure.running\n:global int leon.adventure.maxDifficulty\n\n:local double difficulty\n:local bool parity\n:local bool needs_something\n:local bool skipped\n\n:local string dir\n\n#needs_bombs adventure.bombs() < 99 && difficulty >= 80. && adventure.hasItem(\"leechSword\")\n#needs_health adventure.playerHealth() < 99 && adventure.hasItem(\"leechSword\")\n#needs_mana adventure.mana() < 99 && adventure.hasItem(\"manaReaver\")\n#needs_keys adventure.keys() <= 10\n#num_enemies round(difficulty * 0.1 + 3.)\n#elite_dmg d2i(floor(difficulty * 0.01 + 1.)) * (d2i(ceil(ceil(difficulty * 0.39) * 1.5)) - adventure.playerArmor())\n\ngoto(start)\n\nnext:\nparity = false == parity\nleon.adventure.path = dir\nexecutesync(\"{package}:follow path\")\nstart:\ndifficulty = {cur_difficulty(0.)}\nneeds_something = {survivable(difficulty)} && ({needs_bombs} || {needs_health} || {needs_mana} || {needs_keys})\ndir = sub(\"XU	D  L  R\", index(\" 918 90 09 189\", x(adventure.playerPos()) . y(adventure.playerPos()), 0), 1)\nskipped = contains(\"UDLR\", dir) && (\\n  (adventure.countEntities(\"Elite\") > 0) != ({needs_bombs})\\n	 && (adventure.countEntities(\"Elite\") > 0 || adventure.playerHealth() > 100 - d2i({num_enemies} * 1.8))\\n	 || (adventure.countEntities(\"Elite\") > 0 && adventure.playerHealth() <= {elite_dmg})\\n	 || (parity && false == needs_something)\\n)\nexecutesync(if(skipped, \"{package}:xNOOPx\", \"{package}:kill enemies\"))\n\c; Update needs_something after clearing\ngoto(if(\\n  contains(\"UDLR\", dir) && leon.adventure.running && (\\n	 needs_something && ({needs_bombs} || {needs_health} || {needs_mana} || {needs_keys})\\n		|| parity\\n		|| skipped\\n  ),\\n  next,\\n  end\\n))\nend:\nwait(0.)\};"find loot":{:import adventure_lib\n:name {package}:find loot\n\n:global int turbo.cycles.max\n:global int turbo.cycles\n:global bool leon.adventure.running\n:global string leon.adventure.targetPositions\n:global int leon.adventure.maxDifficulty\n\nkey.u()\nkey.j()\n\nisopen(\"arcade\")\n\nleon.adventure.maxDifficulty +=\\n  if(contains(impulse(), \"key.j\"), -1, if(contains(impulse(), \"key.u\"), 1, 0))\ngotoif(end, contains(impulse(), \"key.\"))\n\nstart:\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)\nexecutesync(\"{package}:analyze loot\")\nloop:\nexecutesync(\"{package}:find path\")\nexecutesync(\"{package}:follow path\")\nleon.adventure.targetPositions = sub(leon.adventure.targetPositions, 5, 99999)\ngotoif(loop, len(leon.adventure.targetPositions) > 0 && leon.adventure.running)\nend:\nwait(0.)\};"find path":{:import adventure_lib\n:name {package}:find path\n\n:global string leon.adventure.path\n:global string leon.adventure.targetPositions\n:global int turbo.cycles.max\n:global int turbo.cycles\n\n:local vector curPos\n:local string queue\n:local string idx\n:local string dir\n:local string path\n:local bool cantPhase\n\n#setField(index, value) lss(\"_f\" . {index}, {value})\n#getField(index) lsg(\"_f\" . {index})\n\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)\nleon.adventure.path = \"\"\ncantPhase = false == adventure.hasItem(\"bootsPhasing\")\\n|| 0 < max(\\n  max(\\n	 max(\\n		adventure.countEntities(\"Chest\"),\\n		adventure.countEntities(\"Enemy\")\\n	 ),\\n	 adventure.countEntities(\"Elite\")\\n  ),\\n  adventure.countEntities(\"Mimic\")\\n)\nqueue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . \"S:\"\nloop1:\ncurPos = {firstElementPos}\nidx = sub(queue, 0, 4)\n{setField(if({getField(idx)} != \"\", \"\", idx), {firstElementDir})}\nqueue = sub(queue, 6, 99999) . if({getField(idx)} != {firstElementDir},\\n  \"\",\\n  if(\\n	 adventure.isWall(curPos + vec(0., 1.)) && cantPhase\\n		|| max(x(curPos), y(curPos)) >= 18.\\n		|| x(curPos) < 1.,\\n	 \"\",\\n	 {posToString(x(curPos), y(curPos) + 1.)} . \"U:\"\\n  ) . if(\\n	 adventure.isWall(curPos + vec(0., -1.)) && cantPhase\\n		|| min(x(curPos), y(curPos)) < 1.\\n		|| x(curPos) >= 18.,\\n	 \"\",\\n	 {posToString(x(curPos), y(curPos) - 1.)} . \"D:\"\\n  ) . if(\\n	 adventure.isWall(curPos + vec(1., 0.)) && cantPhase\\n		|| max(x(curPos), y(curPos)) >= 18.\\n		|| y(curPos) < 1.,\\n	 \"\",\\n	 {posToString(x(curPos) + 1., y(curPos))} . \"R:\"\\n  ) . if(\\n	 adventure.isWall(curPos + vec(-1., 0.)) && cantPhase\\n		|| min(x(curPos), y(curPos)) < 1.\\n		|| y(curPos) >= 18.,\\n	 \"\",\\n	 {posToString(x(curPos) - 1., y(curPos))} . \"L:\"\\n  )\\n)\ngoto(if(\\n  queue == \"\" || contains(idx, sub(leon.adventure.targetPositions, 0, 4)),\\n  l2start,\\n  loop1\\n))\n\nloop2:\nleon.adventure.path = dir . leon.adventure.path\ncurPos -= {nextDir(dir)}\nidx = {posToString(x(curPos), y(curPos))}\nl2start:\ndir = {getField(idx)}\ngotoif(loop2, dir != \"S\")\n\nexecutesync(\"{package}:refine path\")\nwait(0.0)\};"follow path":{:import adventure_lib\n:name {package}:follow path\n\n:global string leon.adventure.path\n:global bool leon.adventure.running\n\n:local int stepCount\n:local vector curPos\n:local bool waitChest\n:local vector nextMove\n\n#nextDirection sub(leon.adventure.path, stepCount, 1)\n#nextMove {nextDir({nextDirection})}\n#curEntity adventure.entityType(curPos + {nextDir({nextDirection})})\n\ngoto(start)\n\nbomb:\nadventure.placeBomb()\ngoto(move)\n\nwait:\nadventure.wait()\n\nmove:\nstepCount += 1\nstart:\ncurPos = adventure.playerPos()\nnextMove = {nextMove}\nwaitChest = contains(adventure.entityType(adventure.playerPos() + nextMove), \"Chest\")\n\nmove2:\nexecutesync(\"TE2.2:stop\")\nadventure.move(nextMove)  \c; This is a no-op for invalid (0,0) moves\nexecutesync(\"TE2.2:start\")\n\nloop:\n\c; This uses the spacing of unused values in the index expression to be equivalent\n\c; to lines to skip *backward*. This is much cheaper than having a nested ternary.\n\c; index returns -1 for the fallthrough case. (UDLR -> move)\ngoto(if(\\n  stepCount < len(leon.adventure.path) && leon.adventure.running,\\n  if(\\n	 contains(\"BW\", {nextDirection})\\n		|| x(curPos) != x(adventure.playerPos())\\n		|| y(curPos) != y(adventure.playerPos())\\n		|| waitChest && adventure.entityType(adventure.playerPos() + nextMove) == \"\",\\n	 (move - 1) - index(\"W B\", {nextDirection}, 0),\\n	 move2\\n  ),\\n  end\\n))\n\nend:\nwait(0.)\};"init":{:import adventure_lib\n:name {package}:init\n\n:global double leon.adventure.delay\n:global string leon.adventure.path\n:global bool leon.adventure.running\n:global int leon.adventure.maxDifficulty\n:global string leon.adventure.targetPositions\n:global string leon.adventure.room_direction\n:local int maxDifficultyInit\n\nkey.r()\nkey.i()\n\nisopen(\"arcade\")\n\nmaxDifficultyInit = 81\nleon.adventure.maxDifficulty = if(\\n  contains(impulse(), \"key.i\") || leon.adventure.maxDifficulty == 0,\\n  maxDifficultyInit,\\n  leon.adventure.maxDifficulty\\n)\n\ngoto(if(\\n  contains(impulse(), \"key.i\"),\\n  end,\\n  if(leon.adventure.running, stop, start)\\n))\nstart:\nexecutesync(\"TE2.2:start\")\ngis(\"<size=0>leon.adventure\",0)\nleon.adventure.running = true\nleon.adventure.path = \"\"\nleon.adventure.targetPositions = \"\"\nleon.adventure.room_direction = \"\"\ngss(\"---Stop hiding---\", \"</size=0>\")\nloop:\nexecutesync(\"{package}:clear room\")\nleon.adventure.maxDifficulty = leon.adventure.maxDifficulty + if(\\n  {cur_difficulty(0.)} >= i2d(leon.adventure.maxDifficulty)\\n	 && adventure.isCompleted(adventure.roomCoords()),\\n  2,\\n  0\\n)\ngotoif(loop, leon.adventure.running)\nexecutesync(\"TE2.2:stop\")\nstop:\nleon.adventure.running = false\nend:\nwait(0.)\};"kill enemies":{:import adventure_lib\n:name {package}:kill enemies\n\n#enemyInDir(x, y) adventure.isEnemy(adventure.playerPos() + vec({x},{y}))\n#enemyDirection if({enemyInDir(0., 1.)}, vec(0., 1.),\\n	 if({enemyInDir(1., 0.)}, vec(1., 0.),\\n	 if({enemyInDir(0., -1.)}, vec(0., -1.),\\n	 if({enemyInDir(-1., 0.)}, vec(-1., 0.), vec(0., 0.)))))\n#anyEnemies {enemyInDir(0., 1.)} || {enemyInDir(0., -1.)} || {enemyInDir(1., 0.)} || {enemyInDir(-1., 0.)}\n\nkey.k()\n\nisopen(\"arcade\")\n\ngoto(if(contains(impulse(), \"key.\"), turbostart, loop))\nwait:\nadventure.wait()\n\nattack:\nexecutesync(\"TE2.2:stop\")\nadventure.move({enemyDirection})\n\nturbostart:\nexecutesync(\"TE2.2:start\")\n\nloop:\ngoto(if(\\n  {anyEnemies},\\n  attack,\\n  if(\\n	 max(max(adventure.countEntities(\"Enemy\"), adventure.countEntities(\"Elite\")), adventure.countEntities(\"Mimic\")) > 0,\\n	 wait,\\n	 if(contains(impulse(), \"key.\"), stop, end)\\n  )\\n))\nstop:\nexecutesync(\"TE2.2:stop\")\nend:\nwait(0.)\};"refine path":{:import adventure_lib\n:name {package}:refine path\n\n:global string leon.adventure.path\n\n:local vector curPos\n:local int stepCount\n\n#curDirection sub(leon.adventure.path, stepCount, 1)\n#insert(st,i,val) sub({st},0,{i}) . ({val}) . sub({st},{i},99999)\n#escapeDirection if(\\n  adventure.entityType(curPos + vec(0., 1.)) == \"\"\\n	 && adventure.entityType(curPos + vec(0., 2.)) == \"\"\\n	 && false == adventure.isWall(curPos + vec(0., 1.))\\n	 && y(curPos) < 17.,\\n  \"BUUWDD\",\\n  if(\\n	 adventure.entityType(curPos + vec(0., -1.)) == \"\"\\n		&& adventure.entityType(curPos + vec(0., -2.)) == \"\"\\n		&& false == adventure.isWall(curPos + vec(0., -1.))\\n		&& y(curPos) > 1.,\\n	 \"BDDWUU\",\\n	 if(\\n		adventure.entityType(curPos + vec(-1., 0.)) == \"\"\\n		  && adventure.entityType(curPos + vec(-2., 0.)) == \"\"\\n		  && false == adventure.isWall(curPos + vec(-1., 0.))\\n		  && x(curPos) > 1.,\\n		\"BLLWRR\",\\n		\"BRRWLL\"\\n	 )\\n  )\\n)\n\ncurPos = adventure.playerPos()\ngoto(start)\n\nrock:\nleon.adventure.path = {insert(\\n  leon.adventure.path,\\n  stepCount,\\n  if(adventure.hasItem(\"eodArmor\"), \"BWWW\", {escapeDirection})\\n)}\nstepCount += if(adventure.hasItem(\"eodArmor\"), 4, 6)\n\nnextTile:\ncurPos += {nextDir({curDirection})}\nstepCount += 1\n\nstart:\ngoto(if(\\n  stepCount >= len(leon.adventure.path),\\n  end,\\n  if(\\n	 adventure.entityType(curPos + {nextDir({curDirection})}) != \"Rock\" || adventure.hasItem(\"hammer\"),\\n	 nextTile,\\n	 rock\\n  )\\n))\nend:\n	 wait(0.)\};"adventure_lib":{#package Adventure v3.2\n\n#strToVec(str) vec(s2d(sub({str}, 0, 2), -1.), s2d(sub({str}, 2, 2), -1.))\n#posToString(x, y) sub(d2s(({x}) + 200.), 1, 2) . sub(d2s(({y}) + 200.), 1, 2)\n#firstElementPos {strToVec(queue)}\n#firstElementDir sub(queue, 4, 1)\n#cur_difficulty(offset) (max(254. - x(adventure.roomCoords()), x(adventure.roomCoords())) + max(254. - y(adventure.roomCoords()), y(adventure.roomCoords())) + ({offset} - 254.))\n#survivable(difficulty) (\\n  ceil(i2d(adventure.playerAttack()) * if(adventure.hasItem(\"impaler\"), 1.1, 1.)) >=\\n	 round({difficulty} * 0.38 + 1.) + round({difficulty} * 0.08)\\n	 || i2d(adventure.playerArmor()) >= ceil({difficulty} * 0.39)\\n) && i2d(leon.adventure.maxDifficulty) >= {difficulty}\\n  && (adventure.hasItem(\"lantern\") || {difficulty} < 100.)\n#nextX(d) s2d(sub(\"X 0 0 1-1\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextY(d) s2d(sub(\"X 1-1 0 0\", index(\" U D R L\", {d}, 0), 2), 0.)\n#nextDir(d) vec({nextX({d})}, {nextY({d})})\};\};\};{"TE2.2":{"turbo_2.2_start":{\n:name TE2.2:start\n\n\c; This script registers a script for turbo exec, and exits as soon it confirms\n\c; turbo exec is running.\n\c; When executing this script, it is highly advised to execute it using\n\c; `execute(sync)` as among other things, this guarantees that the cycle counter\n\c; has started and that it is safe to overwrite `turbo.cycles.max` with a new\n\c; maximum value.\n\n\n\c; This variable is used to track how many scripts are using turbo exec.\n\c; It's incremented each time `TE2.2:start` is called, and decremented\n\c; every time `TE2.2:stop` is called. When it reaches 0, turbo is stopped\n\c; and waits for the next script to register.\n:global int turbo.register\n\n\c; This variable is used to recieve state information from `<turbo>:register`.\n:global string turbo.state\n\nturbo.register += 1 \c; Increment the registry counter\n\n\c; This should guarantee turbo exec is up and is gonna keep running until\n\c; the next call to `TE2.2:stop` (assuming no script interferes or causes\n\c; undefined behavior).\n\c; For instance, if `TE2.2:start` is called shortly before cycles.max is\n\c; reached (due to another script using turbo), without this check it would\n\c; return just as turbo is stopping.\n\c; `goto` is being used here to stay consistent with `TE2.2:stop`.\nwait:\ngoto(if(contains(turbo.state, \"running\"), end, wait))\n\n\c; Finishing the script with a noop is important, else the script will get\n\c; stuck on the `goto` even after turbo finished.\nwait(0.0)\nend:\};"turbo_2.2_stop":{\n:name TE2.2:stop\n\n\c; This script unregisters a script for turbo exec, signaling that the caller\n\c; script wishes to resume normal execution now, thus, this script only exits\n\c; once it confirms that turbo isn't running anymore.\n\c; When executing this script, it is highly advised to execute it using\n\c; `execute(sync)`. This is especially important if you are gonna start turbo\n\c; again soon after, as this guarantees that a frame skip does happen and thus\n\c; prevents infinite loops, and, if you care about it, this\n\c; guarantees frame continuity as long as you call `TE2.2:start` again within\n\c; the next 2 instructions after this script returns.\n\n\n\c; This variable is used to track how many scripts are using turbo exec.\n\c; It's incremented each time `TE2.2:start` is called, and decremented\n\c; everytime `TE2.2:stop` is called. When it reaches 0, turbo is stopped\n\c; and waits for the next script to register.\n:global int turbo.register\n\n\c; This variable is used to recieve state information from `<turbo>:register`.\n:global string turbo.state\n\n\c; Decrement the registry counter. There intentionally isn't a check for\n\c; negative, because if the calls are unbalanced that behavior should be\n\c; exposed quickly so it can be found and fixed.\nturbo.register -= 1\n\n\c; `turbo.state` first goes through the state \"stopping\", which happens 1 cycle\n\c; early. By exiting one cycle early, the caller script has a 1 cycle buffer to\n\c; call `turbo start` again to preserve frame continuity, but since the frame\n\c; skip is already planned at that point, even if the caller calls `turbo start`\n\c; right after this exits, the frame will be skipped correctly. This allows more\n\c; versatility in the caller's syntax and can save some crucial lines.\n\c; It is important to use `goto` here instead of `waituntil`, otherwise the extra\n\c; cycle would be consumed by waiting for the extra noop instruction at the end.\nwait:\ngoto(if(contains(turbo.state, \"running\"), wait, end))\n\n\c; Finishing the script with a noop is important, else the script will get\n\c; stuck on the `goto` even after turbo finished.\nwait(0.0)\nend:\};"turbo_register":{\n:name TE2.2:register\n\n\c; This script is the main manager script, it runs the main turbo loop when\n\c; needed and sends state information to other scripts.\n\n\n\c; This variable is used to track how many scripts are using turbo exec,\n\c; it's incremented each time `TE2.2:start` is called, and decremented\n\c; everytime `TE2.2:stop` is called. When it reaches 0, turbo is stopped\n\c; and waits for the next script to register.\n:global int turbo.register\n\n\c; This variable is used to communicate state with other scripts in turbo,\n\c; there are 4 states possible :\n\c; \"stopping\" means turbo should stop on the next cycle, this state is used to\n\c;	  allow a 1-cycle delay on when `TE2.2:start` needs to be called to\n\c;	  guarantee that one and only one frame passed from the last `TE2.2:stop`.\n\c; \"active\" means that this cycle is a \"breaking\" cycle, and forces advancing\n\c;	  to the next frame. The name is chosen because this is what will usually\n\c;	  appear in the variable display when turbo is active.\n\c; \"idle\" means that turbo is idle and waiting for the next script to register\n\c; \"running\" means that turbo is currently running. Note that this state will\n\c;	  never show in the variable display!\n:global string turbo.state\n\n\c; This variable counts the number of cycles since the beginning of the frame,\n\c; although it does have a delay of a few cycles, this doesn't matter for its\n\c; 2 main applications, which are :\n\c; - making sure turbo doesn't run for too long\n\c; - allowing scripts to calculate how many cycles passed between 2 instructions\n:global int turbo.cycles\n\c; This variable determines how many cycles turbo is allowed to run for at most\n\c; on this frame. It is reset each frame. If your script needs turbo to run for\n\c; longer then 200 cycles per frame, you need to set that using this variable.\n\c; To prevent conflicts with other scripts, please make sure to use the\n\c; following instruction to require more cycles :\n\c;\n\c; turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + cycles_you_require)\n\c;\n\c; The reason we add the current number of cycles to the required cycles is\n\c; that turbo exec might have already been running for a while due to another\n\c; script requiring it. If that is the case, we want to make sure we extend\n\c; `turbo.cycles.max` enough to run all the computation and actions we still\n\c; need to do.\n\c;\n\c; There is also a hard-coded limit of 50000 cycles to prevent the game from\n\c; freezing in case a script messed up.\n:global int turbo.cycles.max\n\nwakeup()\n\nturbo.register = 0\n\n\c; Kill TE2.1 scripts if they're present, to avoid compatibility issues.\n\c; TE2.2 and TE2.1 are identical, aside from TE2.2 being in a package, so\n\c; the v2.2 version can handle all the logic.\n\c; Wait one cycle (by setting `turbo.register` first) to avoid script-ordering\n\c; issues\c; this guarantees that the other scripts have already started, if they\n\c; are present. The stops must also be ordered this way to always work correctly.\nstop(\"TE2.1 register\")\nstop(\"TE2.1\")\n\nturbo.state = \"idle\"\nturbo.cycles.max = 200\nwait:\nwaituntil(turbo.register > 0) \c; Wait for a script to register\nskipwait:\nexecute(\"TE2.2:counting\")\c;\n\nturbo.state = \"running\"\n\n\c; Reset cycles.max to its default value at the start of each frame, even if a\n\c; script fails to call `TE2.2:stop` in time, it's better to reset this value\n\c; as the script is already in undefined behavior territory and it's preferable\n\c; to not hold back other scripts because of a defective script.\n\c; Because this is set right after `turbo.state`, even if a script tries to\n\c; overwrite this right after calling `TE2.2:start`, this won't cause a race\n\c; condition (assuming `TE2.2:start` was executed using `execute(sync)`).\nturbo.cycles.max = 200\n\n\c; Wait for conditions to end the frame.\n\c; This is written oddly, with \"min\" instead of \"||\", because \"||\" is actually\n\c; a trinary function and thus slower to execute. Every bit counts here in\n\c; the hottest cycle of turbo.\nwaituntil(0 >= min(turbo.register, min(turbo.cycles.max, 50000) - turbo.cycles))\n\n\c; This doesn't look like much, but this is the most crucial part of this\n\c; script, by signaling scripts 2 cycle earlier, and going through 4 different\n\c; states, we enable the groundwork for a lot of QOL features and optimizations.\n\c; The reason we need to buffer for 2 cycles is that one of the cycles is used up\n\c; when `execsync(\"TE2.2:stop\")` ends.\n\nturbo.state = \"stopping\" \c; About to change to the next frame\nwait(0.0)					 \c; Buffered instructions\nturbo.state = \"active\"	\c; Changing to the next frame on this cycle\nturbo.state = \"idle\"	  \c; Idle state, waiting for registration\n\n\c; Save a cycle if registration already happened\ngoto(if(turbo.register > 0, skipwait, wait))\};"turbo":{\n:name TE2.2:turbo\n\n\c; This script combined with `TE2.2:active` forms the core of turbo exec v2.\n\c; Be careful: If it remains in \"turbo\" mode without ever changing state,\n\c; the game is gonna freeze and then crash.\n\n\c; The number of scripts using turbo exec.\n:global int turbo.register\n\n\c; This variable is used to recieve state information from `<turbo>:register`\n:global string turbo.state\n\nwakeup()\n\n\c; To function, this operates closely coupled with `TE2.2:active`, which has a\n\c; single instruction: execute(\"TE2.2:turbo\")\n\c;\n\c; To understand how this functions, first understand that there are exactly\n\c; two states that the scripts can be in after a cycle: Either\n\c; 1) `TE2.2:turbo` is about to run line #2, and `TE2.2:active` isn't running.\n\c; 2) `TE2.2:active` is about to run line #1, and `TE2.2:turbo` isn't running.\n\c;\n\c; Every cycle, `TE2.2:active` runs its action, either because it was already\n\c; running or because it is executed by `TE2.2:turbo` on line #2. This launches\n\c; a new copy of `TE2.2:turbo`, and the new state is completely determined by\n\c; the \"if\" condition on line #1.\n\c;\n\c; If the \"if\" is true, `TE2.2:turbo` is stopped, which causes \"turbo exec\" behaviour\n\c; because a script is stopping itself: The current script pointer is reset to\n\c; the beginning, effectively giving a \"free\" cycle to all scripts before it in\n\c; the script list. The turbo exec bug/feature also prevents scripts at the end\n\c; from exiting, so `TE2.2:active` will remain on line #1.\n\c;\n\c; If the \"if\" is false, `TE2.2:active` is stopped, and `TE2.2:turbo` will\n\c; execute line #2 next frame. This is \"regular execution mode.\"\n\c;\n\c; A side-effect of the way this works is that `TE2.2:turbo` is the only script that\n\c; will be running at the end of a frame, so it is the only one that will ever\n\c; be visible in the scripts list.\n\c;\n\c; The \"contains\" is an optimization for checking multiple values at once. AI\n\c; performance is based on how many \"nodes\" are evaluated, and boolean\n\c; operations like \"||\" are actually trinary functions, and thus surprisingly\n\c; expensive. The concat with [] is necessary to avoid matching when\n\c; turbo.state is empty, which happens on startup.\n\c; In most places, readability matters more, but here in the hottest loop of\n\c; turbo, every bit counts.\n\nstop(if(contains(\"[running][stopping]\", \"[\" . turbo.state . \"]\") || contains(turbo.state, \"idle\") && turbo.register > 0, \"TE2.2:turbo\", \"TE2.2:active\"))\nexecute(\"TE2.2:active\")\};"turbo_active":{\n:name TE2.2:active\n\n\c; This script combined with turbo forms the core of turbo exec v2.\n\c; To understand how it works, see turbo.tpt2.\n\nexecute(\"TE2.2:turbo\")\};"turbo_counting":{\n:name TE2.2:counting\n\n\c; This script counts the number of elapsed cycles since its execution.\n\c; This is used to halt turbo if it runs for too long.\n\n:global int turbo.cycles\n\nturbo.cycles = 0\nturbo.cycles += 1\n\c; Since scripts aren't removed from the script list as long as turbo is\n\c; running, their last instructions are instead run every cycle. This allows\n\c; repeating the same instruction each cycle.\};"turbo_start":{\n:name turbo start\n\n\c; This script is a compatibility script for supporting TE2.1 scripts.\n\c; It performs the same functions as TE2.2:start, but with a different\n\c; script name.\n\n\n\c; This variable is used to track how many scripts are using turbo exec.\n\c; It's incremented each time `turbo start` is called, and decremented\n\c; every time `turbo stop` is called. When it reaches 0, turbo is stopped\n\c; and waits for the next script to register.\n:global int turbo.register\n\n\c; This variable is used to recieve state information from `<turbo> register`.\n:global string turbo.state\n\nturbo.register += 1 \c; Increment the registry counter\n\n\c; This should guarantee turbo exec is up and is gonna keep running until\n\c; the next call to `turbo stop` (assuming no script interferes or causes\n\c; undefined behavior).\n\c; For instance, if `turbo start` is called shortly before cycles.max is\n\c; reached (due to another script using turbo), without this check it would\n\c; return just as turbo is stopping.\n\c; `goto` is being used here to stay consistent with `turbo stop`.\nwait:\ngoto(if(contains(turbo.state, \"running\"), end, wait))\n\n\c; Finishing the script with a noop is important, else the script will get\n\c; stuck on the `goto` even after turbo finished.\nwait(0.0)\nend:\};"turbo_stop":{\n:name turbo stop\n\n\c; This script is a compatibility script for supporting TE2.1 scripts.\n\c; It performs the same functions as TE2.2:stop, but with a different\n\c; script name.\n\n\n\c; This variable is used to track how many scripts are using turbo exec.\n\c; It's incremented each time `turbo start` is called, and decremented\n\c; everytime `turbo stop` is called. When it reaches 0, turbo is stopped\n\c; and waits for the next script to register.\n:global int turbo.register\n\n\c; This variable is used to recieve state information from `<turbo> register`.\n:global string turbo.state\n\n\c; Decrement the registry counter. There intentionally isn't a check for\n\c; negative, because if the calls are unbalanced that behavior should be\n\c; exposed quickly so it can be found and fixed.\nturbo.register -= 1\n\n\c; `turbo.state` first goes through the state \"stopping\", which happens 1 cycle\n\c; early. By exiting one cycle early, the caller script has a 1 cycle buffer to\n\c; call `turbo start` again to preserve frame continuity, but since the frame\n\c; skip is already planned at that point, even if the caller calls `turbo start`\n\c; right after this exits, the frame will be skipped correctly. This allows more\n\c; versatility in the caller's syntax and can save some crucial lines.\n\c; It is important to use `goto` here instead of `waituntil`, otherwise the extra\n\c; cycle would be consumed by waiting for the extra noop instruction at the end.\nwait:\ngoto(if(contains(turbo.state, \"running\"), wait, end))\n\n\c; Finishing the script with a noop is important, else the script will get\n\c; stuck on the `goto` even after turbo finished.\nwait(0.0)\nend:\};\};\}