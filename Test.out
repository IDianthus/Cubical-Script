"D0S.Factory": {
	"factory macros": {

		; Infrastructure for producing all the constants in the factory package.
		; Since this is :imported, it can't produce any instructions.

		#script_name(name) D0S.factory {version}:{name}

		; Key assignments. You can edit these here, or you can edit them later in the
		; generated script (but you will have more places to modify).
		#up w
		#down s
		#left a
		#right d
		#start f

		; Shared hidden variables for the UI
		#action "<size=0>fa#"
		#status "fs#"

		; Produces the name of the queue variable for the given tier and item.
		#queue_str "cq"
		#queue(tier, item) -1 + 10 * ({item}) + {tier}

		; Raw access to the queue. Not preferred, but better than using "queue"
		; directly. Use for low-level optimization.
		#get_raw(raw_item) global.double.get({queue_str} . (100 + {raw_item}))
		#set_raw(raw_item, value) global.double.set({queue_str} . (100 + {raw_item}), {value})

		; Helper macros for operating on the craft_queue. These should be
		; used instead of direct access whenever possible.
		#get_queue(tier, item) {get_raw({queue({tier}, {item})})}
		#set_queue(tier, item, value) {set_raw({queue({tier}, {item})}, {value})}

		; Increment a value in the queue. Although it expands to the same thing,
		; it saves a lot of boilerplate in the source and makes it easier to understand
		; what's going on.
		#add_queue(tier, item, value) {set_queue({tier}, {item}, {get_queue({tier}, {item})} + {value})}
		#subtract_queue(tier, item, value) {set_queue({tier}, {item}, {get_queue({tier}, {item})} - ({value}))}

		; Used with factory.composite_string to extract the name from the
		; returned data.
		#get_name sub(itemdata, 0, index(itemdata, " ", 0))

		; These macros can only be called *after* factory.composite_string,
		; i.e. later on in the script.
		#items_count {lua(return factory.items_count)}
		#tiers_char sub(itemdata, {lua(return factory.entry_size - 1)}, 1)

		{lua(\

			factory = {};
			factory.items = {};
			factory.item_names = {};

			factory.categories = {};

			factory.prods = {};
			factory.prod_machines = {};

			factory.name_max_size = 0;
			factory.game_name_sizes = {};
			factory.game_name_sizes.item = 0;
			factory.game_name_sizes.craft = 0;
			factory.game_name_sizes.group = 0;
			factory.game_name_sizes.special = 0;

			factory.group_map = {};
			factory.group_map.item = 0;
			factory.group_map.craft = 1;
			factory.group_map.group = 2;
			factory.group_map.special = 2; --[[Intentionally the same]]

			function factory.add_item(name, tiers, game_name, craft_type) {

				local item = {};
				item.id = #factory.items + 1;

				if (item.id > 89) {
					return "Too many items: Over the limit while adding " .. name;
				}

				item.name = name;
				item.game_name = game_name;
				item.tier = tiers;
				item.craft_type = craft_type;
				factory.items[item.id] = item;
				factory.item_names[name] = item;

				if (#name > factory.name_max_size) {
					factory.name_max_size = #name;
				}
				if (#game_name > factory.game_name_sizes[craft_type]) {
					factory.game_name_sizes[craft_type] = #game_name;
				}
				return ":const int " .. name .. " " .. #factory.items;
			}

			function factory.composite_string(var, filter, use_group_info) {

				local acc = {};
				local size = 0;
				local first = #factory.items;
				local last = 0;
				local group_map = factory.group_map;

				size = if(filter == nil, 1, 2)
					1. math.max(factory.game_name_sizes["item"], factory.game_name_sizes["craft"]);
					2. factory.game_name_sizes[filter];

				size = size + 1;
				local fmt = "%-" .. size .. "s%d";
				size = size + 1;
				acc[1] = 'sub("';
				for (i = 1; i <= #factory.items; i++) {
					local item = factory.items[i];
					if (filter == nil || filter == item.craft_type) {
						acc[#acc + 1] = if (use_group_info, 1, 2)
							1. string.format(fmt, item.game_name, group_map[item.craft_type]);
							2. acc[#acc + 1] = string.format(fmt, item.game_name, item.tier - 1);

						if (i < first) {
							first = i
						}

						if (i > last) {
							last = i;
						}
					}
				}

				acc[#acc + 1] = '", ' .. size .. " * (" .. var .. "), " .. size .. ')';

				factory.items_count = last - first + 1;
				factory.entry_size = size;
				return table.concat(acc);
			}

			function factory.add_category(name, ...) {

				local category = {};
				factory.categories[#factory.categories + 1] = category;
				category.name = name;
				local name1, name2, name3 = "default", "first", "last";
				local arg1, arg2, arg3 = ...;

				for (i = 1; i <= 3; i++) {

					local trimmed = arg1:gsub("^ +", "");
					local item = factory.item_names[trimmed]

					if (not item) {
						return "Can't find " .. trimmed;
					}

					category[name1] = item.id;
					name1, name2, name3 = name2, name3;
					arg1, arg2, arg3 = arg2, arg3;
				}
			}
		)}

		; Define a new production item with name "name", craftable from tiers 1-"tiers".
		; The string passed to produce() is "game_name".
		; It will take the next available id, starting from 1.
		#item(name, tiers, game_name) {lua(return factory.add_item("{name}", {tiers}, {game_name}, "item"))}

		; Define a new production item with name "name", craftable from tiers 1-"tiers".
		; The string passed to craft() is "game_name".
		; It will take the next available id, starting from 1.
		#make(name, tiers, game_name) {lua(return factory.add_item("{name}", {tiers}, {game_name}, "craft"))}

		; Define a new item group, i.e. a set of items designed to be scanned in the
		; crafter. Because items need a valid game_name to be passed to count() in
		; various places (or else there will be spurious logging), we use "ore".
		; (The value returned from count() will always be ignored.)
		#group(name, tiers) {lua(return factory.add_item("{name}", {tiers}, "ore", "group"))}

		; Defines a "special" item. This has a real name, like an item, but acts
		; like an item-group in other ways. This is used for lumps and ore, which
		; require special-case handling.
		#special(name, tiers, game_name) {lua(return factory.add_item("{name}", {tiers}, {game_name}, "special"))}

		; Defines a category grouping for the UI. "First" and "last" are the span of
		; the group (inclusive), in item names. Must be called *after* the relevant items
		; are defined.
		#category(name, default, first, last) {lua(return factory.add_category("{name}", "{default}", "{first}", "{last}"))}
	};

	"factory constants": {
		:import factory macros

		#version v3.2.1

		; Everything in the list below is a valid target for automation, and can be
		; assigned to the "target_type" variable in "lanuch factory craft".
		; For example, "make(oven, 10, "machine.oven")" indicates that "oven" is a valid
		; item, usable from tiers 1-10, with the internal game name of "machine.oven"
		; (which you don't need to worry about.)
		; Thus you can enter "oven" in the box in the in-game editor (without the quotes).

		; If you add or change this list, mind this constraint:
		; * All the crafted items have to come before the rest of the items.
		; * All the item-groups must be in a single block.
		; * Prefer keeping things in alphabetical order within categories, because
		;   they are ordered the same way when presented in-game.

		; ===== VALID IDS =====

		; *** To reiterate, just use the name part (i.e. "white_producer"), not the whole thing! ***

		; ----- CRAFTED ITEMS -----

		; Producers, named by building, tiers 1-5
		{make(arcade_producer, 5, "producer.arcade")}
		{make(construction_firm_producer, 5, "producer.constructionFirm")}
		{make(exotic_producer, 1, "producer.exoticgems")}
		{make(factory_producer, 5, "producer.factory")}
		{make(gem_producer, 1, "producer.gems")}
		{make(headquarters_producer, 5, "producer.headquarters")}
		{make(laboratory_producer, 5, "producer.laboratory")}
		{make(mine_producer, 5, "producer.mine")}
		{make(museum_producer, 5, "producer.museum")}
		{make(powerplant_producer, 5, "producer.powerplant")}
		{make(pumpkin_producer, 1, "pumpkin.producer")}
		{make(shipyard_producer, 5, "producer.shipyard")}
		{make(statue_of_cubos_producer, 5, "producer.statueofcubos")}
		{make(town_producer, 5, "producer.town")}
		{make(tradingpost_producer, 5, "producer.tradingpost")}
		{make(workshop_producer, 5, "producer.workshop")}

		; Boosters, tiers 1-3
		{make(acceleration_booster, 3, "booster.acceleration")}
		{make(production_booster, 3, "booster.production.regular")}
		{make(resource_booster, 3, "booster.resource.drops")}

		{category(prod, town_producer, arcade_producer, resource_booster)}

		; Machines, tiers 1-10
		{make(assembly, 10, "machine.assembler")}
		{make(belt, 10, "machine.transportbelt")}
		{make(boiler, 10, "machine.boiler")}
		{make(crusher, 10, "machine.crusher")}
		{make(cutter, 10, "machine.cutter")}
		{make(mixer, 10, "machine.mixer")}
		{make(oven, 10, "machine.oven")}
		{make(presser, 10, "machine.presser")}
		{make(refiner, 10, "machine.refinery")}
		{make(shaper, 10, "machine.shaper")}

		{category(mach, belt, assembly, shaper)}

		; Various crafted parts
		{make(block, 10, "block")}
		{make(chip, 5, "chip")}
		{make(hammer, 1, "hammer")}
		{make(insul_cable, 10, "cable.insulated")}
		{make(motor, 10, "motor")}
		{make(pump, 10, "pump")}
		{make(rainbow_dust, 1, "dust.rainbow")}
		{make(rubber_sapling, 1, "sapling.rubber")}
		{make(stacked_plate, 10, "plate.stack")}
		{make(stacked_pumpkin, 1, "pumpkin.stack")}
		{make(void_sapling, 1, "sapling.void")}

		{category(crft, chip, block, void_sapling)}

		; Transforms ore into dust, tiers 1-10
		; Because of an implementation detail, this must come before any
		; scannable items.
		; This doesn't show up in any category in the UI.
		{special(ore, 10, "ore")}

		; ----- SCANNABLE ITEM GROUPS -----
		; These are not real items, but rather groups of items that will be made together
		; if you select one of these names. They are meant for use with the Crafter, to
		; crank out sets of items to scan quickly. You will want to set the quantity to 1000.

		; Notes on using item groups:
		; * SCAN YOUR ORES FIRST! The factory can and will consume your ore to make stuff,
		;     and it takes a long time to get 1000 T10 ore.
		; * The quantity works a little differently than normal items. Instead of making
		;     1000 items each time, running it again will top off everything to be
		;     *at* the quantity of 1000 items.
		; * If you craft a higher tier after a lower tier, it will consume the results
		;     of the first craft to make the higher tier. Scan all the items first, before
		;     moving on to the next tier!
		; * None of these groups include Gem Producers or Exotic Producers. They are too
		;     expensive in comparison to other things, craft them on your own when you
		;     judge the time is right.

		; Makes *everything* (expect special producers and lumps) of the given tier.
		; This is the combination of "chips_and_prods", "machines", and "parts".
		; Requires x10 and high processing speed to have a hope of completing in a
		; reasonable amount of time for T5 and T10.
		; You need Quantum Warehouse to have enough space for this at higher tiers!
		{group(all, 10)}

		; All the tiers of chips. Warning: Expensive. Input this as tier 1.
		{group(chips, 1)}

		; Producers + the chip of the corresponding tier. This is everything that
		; exists in tier range 1-5, for convenience.
		{group(chip_and_prods, 5)}

		; All machines. Tiers 1-10
		{group(machines, 10)}

		; All ingredients and parts. Tiers 1-10. Doesn't include ore (scan that before
		; starting) or lumps (due to technical limitations). Lumps aren't required
		; for anything currently though.
		; Includes rubber plates at tier 1 and hammers at tier *2*.
		; Rubber trees are at tier 9 because of their ore.
		{group(parts, 10)}

		; All producers, except for special producers. Tiers 1-5
		{group(producers, 5)}

		{category(grup, all, all, producers)}

		; ----- INGREDIENTS AND PRODUCED PARTS -----

		; Parts, tiers 1-10
		{item(anti_pumpkin, 1, "pumpkin.anti")}
		{item(board, 10, "plate.circuit")}
		{item(cable, 10, "cable")}
		{item(carved_pumpkin, 1, "pumpkin.carved")}
		{item(circuit, 10, "circuit")}
		{item(dense_block, 10, "block.dense")}
		{item(dense_plate, 10, "plate.dense")}
		{item(ingot, 10, "ingot")}
		{item(pipe, 10, "pipe")}
		{item(plate, 10, "plate")}
		{item(pumpkin_plate, 1, "pumpkin.plate")}
		{item(rainbow_ingot, 1, "ingot.rainbow")}
		{item(rainbow_plate, 1, "plate.rainbow")}
		{item(ring, 10, "ring")}
		{item(rod, 10, "rod")}
		{item(rubber_plate, 1, "plate.rubber")}
		{item(screw, 10, "screw")}
		{item(wire, 10, "wire")}

		{category(part, circuit, anti_pumpkin, wire)}

		;Tries to make dust from ores and lower-tier dusts, tiers 1-10
		; Doesn't appear in the UI
		{item(dust, 10, "dust")}

		; Tiers up dust, tiers 1-9
		; These are ore lumps, plus putting them into the mixer.
		; There is no "only make ore lumps, without mixing them" option right now.
		; Doesn't appear in the UI
		{special(lump, 9, "lump")}

		; Can only be made from saplings
		; Doesn't appear in the UI
		{item(void_essence, 1, "essence.void")}

		; Can only be gotten through the Halloween event
		; Doesn't appear in the UI
		{item(pumpkin, 1, "pumpkin")}

		; Rubber, tier 1 only
		; Doesn't appear in the UI
		{item(rubber, 1, "rubber")}

		; ===== END OF VALID IDS =====
	};

	"worker_storage_lib": {
		; This library will find a slot in the pool of workers to use as "permanent storage".
		; If one doesn't already exist with the given tag, a new one will be allocated,
		; *but* it will avoid overwriting other worker names using the same sytem of tags
		; for storage. Thus, scripts can use this to cooperate without having to
		; explicitly assign worker slot numbers.
		;
		; The scheme is that a name will be prefixed with "[TOKEN]", where "TOKEN" is
		; some short, unique word that will identify the script in question. For instance,
		; the factory might use the word "factory".
		;
		; This library does not actually store anything in the worker name. Instead, it
		; sets the variable "worker_slot", which you must declare in your code.
		; If worker_slot < 100, then it found a valid slot with the worker_prefix.
		; If 100 <= worker_slot < 200, then there was no existing slot, but new data
		; can be initialized at (worker_slot - 100). If worker_slot == 200, then there
		; are no available slots at all, and you should show an error message or take
		; approriate action.
		;
		; A complete example looks like this (replace angle brackets with curlies):
		;
		; :local int worker_slot
		; <worker_lib_line_1([TOKEN])>
		; <worker_lib_line_2>

		; =================================================================================

		#worker_prefix {lua(return worker_lib_prefix)}
		#worker_lacks_prefix sub(worker.name(worker_slot), 0, {len({worker_prefix})}) != "{worker_prefix}"

		; The first macro, which defines the first line and the loop variable that we
		; jump to. We also store the worker_prefix with Lua, so that we don't need to
		; repeat it on the 2nd macro.
		; We don't want to skip slot 0. Doing it like this saves a line.
		#worker_lib_line_1(worker_prefix_arg) {lua(\
			worker_lib_prefix = "{worker_prefix_arg}"\
		)}find_worker_slot_loop: worker_slot = worker_slot + if({worker_lacks_prefix}, 1, 0)

		; The second macro, which iterates until we're done.
		; The test against worker.group() checks for non-existant workers. They would
		; otherwise show as acceptable candidates, and we need to keep iterating to 200
		; in that case.
		#worker_lib_line_2 gotoif(find_worker_slot_loop, \
			worker_slot < 100 && {worker_lacks_prefix} \
			|| worker_slot >= 100 && worker_slot < 200 && (worker.group(worker_slot - 100) == -1 \
			|| contains(sub(worker.name(worker_slot - 100), 0, 1), "["))\
		)
	};

	"recipes": {
		:import factory constants

		{lua(factory.recipes = {})}

		; Infrastructure for defining the recipe list.
		{lua(\

			function factory.recipe(item) {
				local recipe_item = factory.item_names[item];
				if (not recipe_item) {
					return "Unknown item '" .. item .. "'";
				}
				if (recipe_item.recipes) {
					return "Duplicate recipe for '" .. item .. "'";
				}

				factory.recipe_item = recipe_item;
				local offset = 10 * recipe_item.id;

				/*
				There are two types of recipe list that we store
					-"forward" list stored on the item.
						This records what items are needed for crafting
					-"reverse" list stored on the main factory object.
						This is indexed by queue id and records what items can be *made from* the item.
				The forward list is used by the item group system
				The reverse list is used by the recipe system proper.
				*\

				for (i = offset; i < offset + recipe_item.tier; i++) {
					if (not factory.recipes[i]) {
						factory.recipes[i] = {};
					}
				}
				recipe_item.recipes = {};
				for (i = 1; i <= recipe_item.tier; i++) {
					recipe_item.recipes[i] = {};
				}
			}

			function factory.component(tiers, item_name, counts) {
				local recipe_item = factory.recipe_item;
				if (not recipe_item) {
					return "Tried to define a component before calling recipe!";
				}
				local item_name = item_name:gsub(" ", "");
				local item = factory.item_names[item_name];
				if (not item) {
					return "Unknown item '" .. item_name .. "'";
				}
				if (item.craft_type == "group") {
					return string.format(\
						[[Cannot add item "%s" because it is a group]], \
						item.name, \
						recipe_item.name, \
						recipe_item.craft_type\
					);
				}
				local tier_tmp = {};
				for (word in tiers:gmatch("%S+")) {
					local tier = tonumber(word);
					if (not tier) {
						return "Bad tier " .. word;
					}
					tier_tmp[#tier_tmp + 1] = tier;
				}
				if (#tier_tmp != 1 && #tier_tmp != recipe_item.tier) {
					return "Tiers list has wrong size, item " .. recipe_item.name .. " has " .. recipe_item.tier .. " tiers";
				}
				
				local base_tier;
				for (i = 1; i <= recipe_item.tier; i ++) {
					base_tier = tier_tmp[i] or base_tier;
					local tier = base_tier;
					if (tier < 1) {
						tier = tier + i;
					}
					tier_tmp[i] = tier;
				}

				local counts_tmp = {};
				for (word in counts:gmatch("%S+")) {
					local count = tonumber(word);
					if (not count) {
						return "Bad count " .. word;
					}
					counts_tmp[#counts_tmp + 1] = count;
				}
				if (#counts_tmp != 1 && #counts_tmp != recipe_item.tier) {
					return "Counts list has wrong size, item " .. recipe_item.name .. " has " .. recipe_item.tier .. " tiers";
				}
				for (i = #counts_tmp + 1; i <= recipe_item.tier; i ++) {
					counts_tmp[i] = counts_tmp[i-1];
				}

				/*
					Finally, merge the two expanded lists;
					Distribute the results across the recipes for each tier.
					These recipes are "reversed, " so the AI does not have to remake items
					It's this reversed list that is needed for computing the materials needed when crafting.
				*/

				local recipes = factory.recipes;
				local offset = recipe_item.id * 10 - 1;
				for (i = 1; i <= recipe_item.tier; i ++) {

					local tier = tier_tmp[i];
					local count = counts_tmp[i];

					if (count > 0 && tier > 0) {
					/*
						Tiers less than 1 can happen naturally, due to the negative tier convention, so they are silently dropped. 
						Tiers greater than the the maximum number of tiers are an error.
					*/

					if (tier > item.tier) {
						return "Tier " .. tier .. " > item max tier " .. item.tier;
					}

					local idx = item.id * 10 + tier - 1;
					local comp = recipes[idx];
					if comp == nil {
						comp = {};
						recipes[idx] = comp;
					}
					
					comp[#comp + 1] = offset + i;
					comp[#comp + 1] = count;
					local item_recipe = recipe_item.recipes[i];
					item_recipe[#item_recipe + 1] = idx;
					item_recipe[#item_recipe + 1] = count;
				}
			}

			function factory.produce(item, source, mult, machine) {

				local recipe_item = factory.item_names[item];

				if (not recipe_item) {
					return "Unknown item '" .. item .. "'";
				}
				if (recipe_item.recipes) {
					return "Duplicate recipe for '" .. item .. "'";
				}

				local source_item = factory.item_names[source];
				if (not source_item) {
					return "Unknown item '" .. source .. "'";
				}
				if (source_item.tier != recipe_item.tier) {
					return "Tier mismatch: " .. source .. "(" .. source_item.tier ..") vs " .. item .. "(" .. recipe_item.tier .. ")"\
				}

				if (#factory.prods == 0 || factory.prods[#factory.prods].machine != machine) {

					if (factory.prod_machines[machine]) {
						return "Found 2nd group for machine '" .. machine .. "'";
					}
					factory.prod_machines[machine] = #factory.prods + 1;
					factory.prod_machines[#factory.prod_machines + 1] = machine;
				}
				local prod = {};
				prod.item = recipe_item;
				prod.source = source_item;
				prod.mult = mult;
				prod.machine = machine;
				factory.prods[#factory.prods + 1] = prod;

				local offset = 10 * source_item.id;
				local count = 1 / mult;
				for (i = offset; i < offset + recipe_item.tier; i ++) {

					if (not factory.recipes[i]) {
						factory.recipes[i] = {};
					}
					local recipe = factory.recipes[i];
					recipe[#recipe + 1] = 10 * recipe_item.id - offset + i;
					recipe[#recipe + 1] = count;
				}
				recipe_item.recipes = {};
				for (i = 1; i <= recipe_item.tier; i ++) do\
					local recipe = {};
					recipe[1] = offset + i - 1;
					recipe[2] = count;
					recipe_item.recipes[i] = recipe;
				end\
			}

			function factory.check_recipes() {
				for (i = 1; i <= #factory.items; i ++) {
					local item = factory.items[i];
					if (not item.recipes) {
						return item.name .. "(" .. item.id .. ") has no assigned recipe!";
					}
				}
			}
		)}

		; Every recipe begins with this line. There must be one (and only one)
		; recipe declaration for each item, even if there is no way to make it
		; (like for rubber).
		#recipe(item) {lua(return factory.recipe([[{item}]]))}

		; After starting a recipe, list its components with this. A component
		; declares a single item that is used, and the the tiers and counts of that
		; item for each tier of the recipe_item that's being made.
		; The list on the left side is the tiers, the list on the right is the counts.
		;
		; For instance:
		;  recipe(white_producer)
		;  component(2 3 5 7 9, screw, 2 4 4 4 4)
		; Means that a T1 white_producer needs 2 T2 screws, a T2 white_producer needs
		; 4 T3 screws, T3 requires 4 T5 screws, etc.
		; 
		; There are additional space-saving wrinkles. Instead of repeating a number
		; for every tier or every count when it's always the same, you can list it
		; once. This is all-or-nothing: It must be exactly once, or listed once for
		; every tier in the recipe.
		; Also, in the tier list you can use numbers less than 1. This means that
		; the position in the list will be added to the number. I.e. a value of
		; 0 becomes equal to "current_tier", -1 becomes "current_tier - 1", etc.
		#component(tiers, item, counts) {lua(\
		return factory.component([[{tiers}]], [[{item}]], [[{counts}]]);
		)}

		; For items that are made in machines, use this macro instead. This defines
		; the needed recipe automatically. The third argument is the "multiplier",
		; which says how many multiples of the item are made from a single source
		; input.
		; It is assumed that the production happens for all tiers of the item,
		; from the same source tier; things like mixing or boiling dust aren't handled
		; through this system. (Boiling isn't handled at all.)
		#produce(item, source, mult, machine) {lua(\
		return factory.produce(\
			[[{item}]], \
			string.gsub([[{source}]], " ", ""), \
			{mult}, \
			string.gsub([[{machine}]], " ", "")\
		);
		)}

		; ===== BEGIN RECIPES =====

		{recipe(town_producer)}
		{component(2 3 5 7 9, screw, 2 4 4 4 4)}
		{component(2 0 0 0 0, plate, 2 0 0 0 0)}
		{component(0 3 5 7 9, board, 0 2 2 2 6)}
		{component(-1, chip, 0 2 2 2 4)}
		{component(-1, town_producer, 1)}

		{recipe(factory_producer)}
		{component(1 3 5 7 9, wire, 1 4 4 4 4)}
		{component(2 0 0 0 0, screw, 1 0 0 0 0)}
		{component(0 3 5 7 9, board, 0 1 1 1 3)}
		{component(2 3 5 0 0, plate, 2 2 2 0 0)}
		{component(0 0 0 7 9, dense_plate, 0 0 0 2 4)}
		{component(1 1 2 3 4, chip, 2 1 1 1 3)}
		{component(-1, factory_producer, 1)}

		{recipe(mine_producer)}
		{component(2 3 5 7 9, screw, 2 2 2 4 4)}
		{component(1 2 4 6 8, wire, 2 3 2 5 5)}
		{component(2 0 5 7 9, plate, 1 0 1 2 2)}
		{component(0 3 5 7 9, dense_plate, 0 2 2 2 2)}
		{component(1 1 2 3 4, chip, 1)}
		{component(-1, mine_producer, 1)}

		{recipe(workshop_producer)}
		{component(0 2 4 6 8, wire, 0 4 2 8 8)}
		{component(1 3 5 7 9, wire, 4 2 2 2 2)}
		{component(2 3 5 7 9, plate, 1 2 2 2 2)}
		{component(1 0 2 3 4, chip, 1 0 2 2 2)}
		{component(-1, workshop_producer, 1)}

		{recipe(construction_firm_producer)}
		{component(2 4 6 8 10, rod, 3 4 10 10 10)}
		{component(2 4 6 8 10, plate, 2)}
		{component(1 1 2 3 4, chip, 1 2 2 2 2)}
		{component(-1, construction_firm_producer, 1)}

		{recipe(laboratory_producer)}
		{component(0 3 5 7 9, pipe, 0 3 5 10 14)}
		{component(2 4 6 8 10, motor, 1)}
		{component(1 3 5 7 9, dense_plate, 2 2 4 4 6)}
		{component(0, chip, 3 2 4 4 6)}
		{component(-1, laboratory_producer, 1)}

		{recipe(headquarters_producer)}
		{component(1 3 5 7 9, wire, 2 4 8 8 12)}
		{component(2 4 6 8 10, motor, 1 2 2 2 2)}
		{component(0, chip, 3 2 4 4 6)}
		{component(-1, headquarters_producer, 1)}

		{recipe(powerplant_producer)}
		{component(1 3 5 7 9, insul_cable, 2 2 4 4 6)}
		{component(2 4 6 8 10, motor, 1)}
		{component(0 3 5 7 9, block, 0 3 5 5 14)}
		{component(0, chip, 3 2 4 4 6)}
		{component(-1, powerplant_producer, 1)}

		{recipe(arcade_producer)}
		{component(2 4 6 8 9, insul_cable, 4 6 6 6 6)}
		{component(2 4 6 8 10, pipe, 4 4 4 4 8)}
		{component(0, chip, 4 4 4 4 6)}
		{component(-1, arcade_producer, 1)}

		{recipe(tradingpost_producer)}
		{component(2 4 6 8 10, ring, 6 8 8 8 12)}
		{component(2 4 6 8 10, plate, 4)}
		{component(0, chip, 2 2 2 2 4)}
		{component(-1, tradingpost_producer, 1)}

		{recipe(shipyard_producer)}
		{component(2 4 6 8 10, insul_cable, 6 8 8 8 12)}
		{component(1 3 5 7 9, block, 4)}
		{component(0, chip, 2 2 2 2 4)}
		{component(-1, shipyard_producer, 1)}

		{recipe(museum_producer)}
		{component(3 5 7 9 10, insul_cable, 6 7 7 7 9)}
		{component(2 4 6 8 10, block, 4 5 5 5 7)}
		{component(0, chip, 2 2 2 2 4)}
		{component(-1, museum_producer, 1)}

		{recipe(statue_of_cubos_producer)}
		{component(1 3 5 7 9, dense_block, 4 5 5 5 7)}
		{component(2 4 6 8 10, motor, 2)}
		{component(2 4 6 8 10, pipe, 2)}
		{component(2 4 6 8 10, pump, 2 3 3 3 5)}
		{component(0, chip, 2 2 2 2 4)}
		{component(-1, statue_of_cubos_producer, 1)}

		{recipe(gem_producer)}
		{component(5, chip, 10)}
		{component(4, chip, 10)}
		{component(10, insul_cable, 2)}
		{component(1, dense_block, 1)}
		{component(2, dense_block, 1)}
		{component(3, dense_block, 1)}
		{component(4, dense_block, 1)}
		{component(5, dense_block, 1)}
		{component(6, dense_block, 1)}
		{component(7, dense_block, 1)}
		{component(8, dense_block, 1)}
		{component(9, dense_block, 1)}
		{component(10, dense_block, 1)}

		{recipe(exotic_producer)}
		{component(5, chip, 10)}
		{component(10, insul_cable, 2)}
		{component(10, dense_block, 10)}
		{component(10, assembly, 1)}
		{component(10, boiler, 1)}
		{component(10, crusher, 1)}
		{component(10, cutter, 1)}
		{component(10, mixer, 1)}
		{component(10, oven, 1)}
		{component(10, presser, 1)}
		{component(10, refiner, 1)}
		{component(10, shaper, 1)}
		{component(10, belt, 1)}

		{recipe(acceleration_booster)}
		{component(2 3 5, chip, 1 4 6)}
		{component(4, plate, 4 0 0)}
		{component(1, rainbow_plate, 0 2 4)}
		{component(4 8 0, circuit, 4 8 0)}
		{component(10, dense_block, 0 0 12)}
		{component(1, void_essence, 0 0 4)}
		{component(-1, acceleration_booster, 2)}

		{recipe(production_booster)}
		{component(1 3 0, chip, 4 4 0)}
		{component(2 7 0, plate, 4 6 0)}
		{component(2 7 10, circuit, 1 4 4)}
		{component(10, dense_block, 0 0 12)}
		{component(1, void_essence, 0 0 4)}
		{component(-1, production_booster, 0 1 4)}

		{recipe(resource_booster)}
		{component(3, plate, 6 0 0)}
		{component(1, rainbow_plate, 0 0 2)}
		{component(1 3 4, chip, 2 2 6)}
		{component(4 8 0, circuit, 1 2 0)}
		{component(0 7 10, block, 0 4 4)}
		{component(1, void_essence, 0 0 1)}
		{component(-1, resource_booster, 0 1 2)}

		{recipe(pumpkin_producer)}
		{component(0, carved_pumpkin, 6)}
		{component(0, anti_pumpkin, 6)}
		{component(0, pumpkin_plate, 20)}

		{recipe(oven)}
		{component(0, plate, 4 6 8 8 8 8 8 8 8 8)}
		{component(0, insul_cable, 2 2 3 3 3 4 4 4 4 4)}
		{component(0, block, 0 0 0 0 0 2 2 2 2 2)}
		{component(-1, oven, 1)}

		{recipe(presser)}
		{component(1, hammer, 2 0 0 0 0 0 0 0 0 0)}
		{component(0, plate, 4 5 7 7 7 9 9 9 9 9)}
		{component(0, wire, 1 1 2 2 2 3 3 3 3 3)}
		{component(0, block, 0 0 0 0 4 5 5 5 5 5)}
		{component(1 1 1 2 2 2 3 3 4 4, chip, 2)}
		{component(-1, presser, 1)}

		{recipe(assembly)}
		{component(0, pipe, 1 1 1 1 1 2 2 2 2 2)}
		{component(0, dense_plate, 6 5 8 8 8 10 10 10 12 12)}
		{component(0, motor, 1 1 1 1 1 1 1 1 2 2)}
		{component(1 1 1 2 2 2 3 3 4 4, chip, 1 1 1 1 1 1 1 1 1 2)}
		{component(-1, assembly, 1)}

		{recipe(refiner)}
		{component(0, block, 0 0 0 0 0 0 5 5 5 7)}
		{component(0, dense_plate, 4)}
		{component(0, motor, 1 1 1 1 2 2 2 2 2 4)}
		{component(0, ring, 1 2 2 2 3 3 3 3 3 5)}
		{component(0, pump, 1 2 2 2 3 3 3 3 3 5)}
		{component(1 1 2 2 2 2 3 4 4 5, chip, 2)}
		{component(-1, refiner, 1)}

		{recipe(mixer)}
		{component(0, dense_plate, 5 4 4 5 5 6 6 6 6 6)}
		{component(0, motor, 2)}
		{component(0, pump, 1 1 1 2 2 3 3 3 3 3)}
		{component(1 1 1 2 2 2 2 3 4 4, chip, 1 1 1 2 2 3 3 3 3 3)}
		{component(-1, mixer, 1)}

		{recipe(crusher)}
		{component(0, dense_plate, 7 8 8 8 8 8 8 9 9 9)}
		{component(0, motor, 1 1 1 1 1 1 1 2 2 2)}
		{component(1 1 1 2 2 2 2 2 4 4, chip, 1 2 2 2 2 2 2 3 3 3)}
		{component(-1, crusher, 1)}

		{recipe(belt)}
		{component(1, rubber, 3 4 4 4 4 0 0 0 0 0)}
		{component(1, rubber_plate, 0 0 0 0 0 4 5 5 5 5)}
		{component(0, motor, 3 3 3 3 3 3 4 4 4 4)}
		{component(0, insul_cable, 3 4 4 4 4 4 5 5 5 5)}
		{component(0 0 0 1 2 2 3 3 4 4, chip, 0 0 0 4 4 4 5 5 5 5)}
		{component(-1, belt, 1)}

		{recipe(cutter)}
		{component(0, plate, 2 2 2 2 2 2 2 0 0 0)}
		{component(0, dense_plate, 3 3 3 3 3 4 4 2 2 2)}
		{component(0, block, 0 0 0 0 0 0 0 4 4 6)}
		{component(0, motor, 3 4 4 4 4 5 5 5 5 7)}
		{component(-1, cutter, 1)}

		{recipe(shaper)}
		{component(0, plate, 4 4 4 4 4 4 4 4 4 0)}
		{component(0, dense_plate, 0 0 0 0 0 0 0 0 0 4)}
		{component(0, screw, 1 2 2 2 2 3 3 3 3 3)}
		{component(0, block, 1 2 2 2 2 3 3 3 3 0)}
		{component(0, dense_block, 0 0 0 0 0 0 0 0 0 5)}
		{component(0, motor, 2)}
		{component(0, insul_cable, 1 1 1 1 1 2 2 2 2 4)}
		{component(-1, shaper, 1)}

		{recipe(boiler)}
		{component(0, wire, 2 2 2 3 3 3 3 3 4 5)}
		{component(0, dense_plate, 2 2 2 3 3 3 3 3 4 5)}
		{component(0, block, 4 7 7 8 8 8 8 8 9 10)}
		{component(0, motor, 1 1 1 2 2 2 2 2 3 4)}
		{component(0, screw, 2)}
		{component(0, pump, 1)}
		{component(-1, boiler, 1)}

		{recipe(rainbow_dust)}
		{component(1, dust, 1)}
		{component(2, dust, 1)}
		{component(3, dust, 1)}
		{component(4, dust, 1)}
		{component(5, dust, 1)}
		{component(6, dust, 1)}
		{component(7, dust, 1)}
		{component(8, dust, 1)}
		{component(9, dust, 1)}
		{component(10, dust, 1)}

		{recipe(chip)}
		{component(1 3 5 7 9, circuit, 2)}
		{component(2 4 6 8 10, circuit, 2 4 4 2 2)}
		{component(1 3 5 7 9, board, 1 4 4 6 8)}
		{component(2 4 6 8 10, board, 1 2 2 6 8)}
		{component(-1, chip, 0 4 8 12 12)}

		{recipe(insul_cable)}
		{component(0, cable, 1 1 1 2 3 4 5 10 12 16)}
		{component(1, rubber, 1 2 0 0 0 0 0 0 0 0)}
		{component(1, rubber_plate, 0 0 2 4 6 8 10 10 12 16)}

		{recipe(stacked_plate)}
		{component(0, plate, 9)}

		{recipe(stacked_pumpkin)}
		{component(0, pumpkin, 9)}

		{recipe(motor)}
		{component(0, plate, 4)}
		{component(0, screw, 1)}
		{component(0, rod, 2)}
		{component(0, wire, 1)}
		{component(1, rubber, 1)}

		{recipe(pump)}
		{component(0, plate, 2)}
		{component(0, motor, 1)}
		{component(0, ring, 2)}
		{component(1, rubber_plate, 4)}

		{recipe(hammer)}
		{component(2, ingot, 6)}
		{component(2, rod, 1)}

		{recipe(block)}
		{component(0, dense_plate, 8 8 8 8 8 8 12 12 12 12)}

		{recipe(rubber_sapling)}
		{component(0, rubber, 8)}
		{component(9, ore, 1)}

		{recipe(void_sapling)}
		{component(1, rainbow_dust, 8)}
		{component(1, rubber_sapling, 1)}

		{recipe(producers)}
		#recipe_producers(x) \
		{component(0, town_producer, {x})}\
		{component(0, factory_producer, {x})}\
		{component(0, mine_producer, {x})}\
		{component(0, workshop_producer, {x})}\
		{component(0, construction_firm_producer, {x})}\
		{component(0, laboratory_producer, {x})}\
		{component(0, headquarters_producer, {x})}\
		{component(0, powerplant_producer, {x})}\
		{component(0, arcade_producer, {x})}\
		{component(0, tradingpost_producer, {x})}\
		{component(0, shipyard_producer, {x})}\
		{component(0, museum_producer, {x})}\
		{component(0, statue_of_cubos_producer, {x})}
		{recipe_producers(1)}

		{recipe(machines)}
		{component(0, oven, 1)}
		{component(0, presser, 1)}
		{component(0, assembly, 1)}
		{component(0, refiner, 1)}
		{component(0, mixer, 1)}
		{component(0, crusher, 1)}
		{component(0, belt, 1)}
		{component(0, cutter, 1)}
		{component(0, shaper, 1)}
		{component(0, boiler, 1)}

		{recipe(parts)}
		#recipe_parts \
		{component(0, insul_cable, 1)}\
		{component(0, stacked_plate, 1)}\
		{component(0, motor, 1)}\
		{component(0, pump, 1)}\
		{component(1, hammer, 0 1 0 0 0 0 0 0 0 0)}\
		{component(0, block, 1)}\
		{component(0, ingot, 1)}\
		{component(0, plate, 1)}\
		{component(0, dense_plate, 1)}\
		{component(0, dense_block, 1)}\
		{component(0, pipe, 1)}\
		{component(0, cable, 1)}\
		{component(0, wire, 1)}\
		{component(0, rod, 1)}\
		{component(0, ring, 1)}\
		{component(0, screw, 1)}\
		{component(0, board, 1)}\
		{component(0, circuit, 1)}\
		{component(0, rubber_plate, 1 0 0 0 0 0 0 0 0 0)}\
		{component(1, rubber_sapling, 0 0 0 0 0 0 0 0 1 0)}
		{recipe_parts}

		{recipe(chips)}
		{component(1, chip, 1)}
		{component(2, chip, 1)}
		{component(3, chip, 1)}
		{component(4, chip, 1)}
		{component(5, chip, 1)}

		{recipe(chip_and_prods)}
		{component(0, chip, 1)}
		{recipe_producers(1)}

		#recipe_machines_and_parts \
		{component(0, oven, 1)}\
		{component(1, presser, 0 1 0 0 0 0 0 0 0 0)}\
		{component(0, presser, 0 1 1 1 1 1 1 1 1 1)}\
		{component(0, assembly, 1)}\
		{component(0, refiner, 1)}\
		{component(0, mixer, 1)}\
		{component(0, crusher, 1)}\
		{component(0, belt, 1)}\
		{component(0, cutter, 1)}\
		{component(0, shaper, 1)}\
		{component(0, boiler, 1)}\
		{recipe_parts}

		{recipe(all)}
		{component(0, chip, 1 1 1 1 1 0 0 0 0 0)}
		{recipe_producers(1 1 1 1 1 0 0 0 0 0)}
		{recipe_machines_and_parts}

		; Machine-produced items
		{recipe(ingot)} ; Has special-case producing code
		{component(0, dust, 1)}

		{produce(rainbow_ingot, rainbow_dust, 1, oven)}

		{produce(plate, ingot, 1, presser)}
		{produce(rainbow_plate, rainbow_ingot, 1, presser)}
		{produce(dense_plate, stacked_plate, 1, presser)}
		{produce(rubber_plate, rubber, 1, presser)}
		{produce(pumpkin_plate, stacked_pumpkin, 1, presser)}

		{produce(dense_block, block, 1, boiler)}
		{produce(anti_pumpkin, pumpkin, 1, boiler)}

		{produce(rod, ingot, 2, shaper)}
		{produce(pipe, plate, 1, shaper)}
		{produce(ring, rod, 1, shaper)}

		{produce(cable, ingot, 2, refinery)}
		{produce(board, plate, 1, refinery)}
		{produce(wire, cable, 1, refinery)}

		{produce(screw, rod, 4, cutter)}
		{produce(carved_pumpkin, pumpkin, 1, cutter)}

		{produce(circuit, cable, 1, assembler)}

		; These recipes have special-case code to handle them, because of the
		; complexities involved with choosing between ore and lumps for making dust.
		{recipe(lump)}
		{recipe(dust)}

		; Terminal items, unable to be crafted.
		{recipe(ore)}
		{recipe(rubber)}
		{recipe(void_essence)}
		{recipe(pumpkin)}

		; ===== END RECIPES =====

		{lua(return factory.check_recipes())}
	};
	"run_recipes": {
		:import factory constants
		:import recipes

		:name {script_name(produce)}

		:local int i
		:local int machine_idx
		:local double previous_amount
		:local string machine_chunk
		:local string machine_name
		:local string produce_data
		:local string source_name_raw

		key.{left}()
		key.{right}()

		isopen("factory")

		; If we were launched via key impulse, invoke the UI immediately to start turbo,
		; and set action to signal which key was pressed. Otherwise, we're being called
		; as a produce script.
		execute(if(contains(impulse(), "key."), "{script_name(ui)}", "###badname###"))
		gotoif(end, contains(impulse(), "key."))

		; ================== BEGIN MACROS + LUA ==================
		; The data for producing is defined in a single string, stored in
		; produce_data. Each entry in the string is a "produce_chunk", defined
		; in the following format:
		; MULT SOURCE_CHAR DEST_ITEM
		; DEST_ITEM is a 3-byte number, denoting the raw queue value for the item.
		; (I.e. after the +100 addition.) SOURCE_CHAR is a single character that
		; is used for indexing a separate lookup table of the source item names.
		; (The source tier will be the same as the tier of DEST_ITEM.) The MULT
		; is a single number used when items produce multiple output copies.
		#produce_chunk_size 5

		; Here we precompute all our data tables. There are three tables:
		; produce_data, which stores the produce chunks described above.
		; item_names, which stores destination item names only, and
		; machine_data, which stores a combination of machine name and offset into produce_data.
		;
		; We also compute the character lookup table that is used to convert DEST_ITEM to/from
		; numbers for use with item_names.
		{lua(\
		local format = string.format\
		\
		machine_chunk_size = nil\
		machine_data = nil\
		item_names = nil\
		item_names_size = nil\
		trans_table = "0123456789abcdefghijklmnopqrstuvwxyz"\
		produce_data = nil\
		\
		local function pad_strings(arr)\
			local max = 0\
			for i = 1, #arr do\
				max = max >= #arr[i] and max or #arr[i]\
			end\
			max = max + 1\
			local fmt_str = format("%%%ds", -max)\
			local res = {}\
			for i = 1, #arr do\
				res[i] = format(fmt_str, arr[i])\
			end\
			return res, max\
		end\
		\
		local machine_acc = {}\
		local item_acc = {}\
		local prod_acc = {}\
		local prods_offset = 1\
		local offsets = {}\
		factory.prod_machines[#factory.prod_machines + 1] = "end"\
		factory.prod_machines["end"] = #factory.prods + 1\
		for i = 1, #factory.prod_machines do\
			local machine = factory.prod_machines[i]\
			machine_acc[i] = machine\
			local next_offset = factory.prod_machines[machine]\
			for j = 1, 10 do\
				for k = prods_offset, next_offset - 1 do\
				local prod = factory.prods[k]\
				if prod.source.tier < j then goto continue end\
				local source_name = prod.source.game_name\
				if not item_acc[source_name] then\
					item_acc[#item_acc + 1] = source_name\
					item_acc[source_name] = #item_acc\
				end\
				prod_acc[#prod_acc + 1] = prod.mult ..\
					string.sub(trans_table, item_acc[source_name], item_acc[source_name]) ..\
					prod.item.id * 10 + 100 + j - 1\
				::continue::\
				end\
			end\
			offsets[i] = format("%03d", #prod_acc * 5)\
			prods_offset = next_offset\
		end\
		if #prod_acc * 5 > 999 then\
			return "Offset overflows three digits: " .. table.concat(offsets, " ")\
		end\
		machine_acc, machine_chunk_size = pad_strings(machine_acc)\
		for i = 1, #machine_acc do\
			machine_acc[i] = offsets[i] .. machine_acc[i]\
		end\
		\
		machine_data = table.concat(machine_acc)\
		machine_chunk_size = machine_chunk_size + 3\
		item_acc, item_names_size = pad_strings(item_acc)\
		item_names = table.concat(item_acc)\
		trans_table = string.sub(trans_table, 1, #item_acc)\
		produce_data = table.concat(prod_acc)\
		\
		--[[Debug functions, uncomment as needed]]\
		--[[return table.concat(prod_acc, ", ")]]\
		)}

		;{lua(return produce_data)}_
		;{lua(return machine_data)}
		;{lua(return item_names)}
		;{lua(return trans_table)}_

		; When it is loaded from produce_data, the value in produce_data is
		; processed from the raw produce_chunk to lookup the SOURCE_CHAR from the
		; secondary lookup table. This still needs extra processing to trim the
		; trailing spaces, which is why the source_name macro exists.
		#dest_offset 2
		#source_char_offset 1
		#mult_offset 0
		#get_source_tier index(" 0123456789", sub(produce_data, {dest_offset} + 2, 1), 0)
		#source_name sub(source_name_raw, 0, index(source_name_raw, " ", 0))
		#mult s2d(sub(produce_data, {mult_offset}, 1), 0.)

		#next_offset s2i(sub(machine_chunk, {lua(return machine_chunk_size)}, 3), 0)

		; Raw access to the queue. This is even more direct than
		; get_raw, because we're using queue strings directly.
		#raw_dest sub(produce_data, {dest_offset}, 3)
		#get_dest global.double.get({queue_str} . {raw_dest})
		#set_dest(value) global.double.set({queue_str} . {raw_dest}, {value})
		; ================== END MACROS + LUA ==================

		executesync("{script_name(produce dust)}")
		stop("{script_name(produce dust)}")

		machine_loop:
		; Setup machine data variables and set the produce index to the proper place.
		; We break this out into separate variables because we don't run through this
		; section as much (only once per machine, so ~8 times), and it makes the later
		; expressions more efficient. Also, we have lines to spare.
		; We get 3 extra characters after the machine chunk so that we have the next
		; offset available as well, which we use to determine when to finish the produce_loop
		; below and procede to the next machine.
		machine_chunk = sub("{lua(return machine_data)}", machine_idx, {lua(return machine_chunk_size)} + 3)
		machine_name = sub(machine_chunk, 3, index(machine_chunk, " ", 0) - 3)
		i = s2i(sub(machine_chunk, 0, 3), 0)
		machine_idx += {lua(return machine_chunk_size)}

		; We need to setup the production data anyway, so we branch there. This is
		; one instruction less efficient than other methods, but it lets us
		; reuse a lot of code so it's worth it.
		goto(if(\
		contains("end", machine_name), \
		end, \
		set_data\
		))

		produce_loop:
		source_name_raw = sub(\
		"{lua(return item_names)}", \
		index(\
			"{lua(return trans_table)}", \
			sub(produce_data, {source_char_offset}, 1), \
			0\
		) * {lua(return item_names_size)}, \
		{lua(return item_names_size)}\
		)

		; Uncomment this line for runtime production debugging.
		; You will also need to uncomment the line in run_recipes that unhides debug.
		;gss("debug", gsg("debug") . "<br>" . {source_name} . {get_source_tier} . "_" . min(ceil({get_dest} / {mult}), count({source_name}, {get_source_tier})) . machine_name)

		; Just try to produce. There is a wrinkle here not present when crafting:
		; we take the minimum with the source count, so that we can use items as
		; quickly as they become available. We only craft the entire quantity, to
		; avoid needlessly filling the inventory.
		produce(\
		{source_name}, \
		{get_source_tier}, \
		min(ceil({get_dest} / {mult}), count({source_name}, {get_source_tier})), \
		machine_name\
		)

		; We can blindly subtract the number of items in the machine, because we've
		; guaranteed via the guards on our loop that we exit as soon as the machine
		; is active. This means the item in there *must* be the correct one, if the
		; count is > 0.
		{set_dest({get_dest} - {mult} * machine.item.count(machine_name))}

		next_item:
		i += {produce_chunk_size}
		set_data:
		produce_data = sub("{lua(return produce_data)}", i, {produce_chunk_size})

		; Go to the next machine if we're done with this set of machines, or the machine
		; has become active. Otherwise, either produce the next item, or skip it if
		; the quantity is <= 0.
		goto(if(\
		i >= {next_offset}, \
		machine_loop, \
		if(\
			active(machine_name), \
			machine_loop, \
			if(\
				{get_dest} <= 0., \
				next_item, \
				produce_loop\
			)\
		)\
		))

		end:
		gss({action}, if(\
		contains(impulse(), "key."), \
		if(\
			contains(impulse(), "key.{left}"), \
			"1", \
			"-1"\
		), \
		gsg({action})\
		))
	};
	"produce": {
	};
	"produce dust": {
		:import factory constants

		:name {script_name(produce dust)}

		:local int _tier
		:local double previous_amount

		_tier = _tier + 1
		previous_amount = count("ore", _tier)
		produce("ore", _tier, {get_queue(_tier, ore)}, "crusher")
		{subtract_queue(_tier, dust, (previous_amount - count("ore", _tier)) * 2.)}
		{subtract_queue(_tier, ore, previous_amount - count("ore", _tier))}

		gotoif(notierupdust, _tier >= 10 || {get_queue(_tier, lump)} <= 0. || active("mixer"))
		craft("lump", _tier, min(\
		min(\
			(count("dust", _tier) - 1.) / 4., \
			count("dust", _tier + 1)\
		), \
		{get_queue(_tier, lump)} - count("lump", _tier)\
		))
		previous_amount = count("lump", _tier)
		produce("lump", _tier, min(previous_amount, {get_queue(_tier, lump)}), "mixer")
		{subtract_queue(_tier, dust, previous_amount - count("lump", _tier))}
		{subtract_queue(_tier, lump, previous_amount - count("lump", _tier))}
		notierupdust:

		gotoif(noproduceingot, active("oven") | (if(_tier == 10, 0., ({get_queue(_tier, lump)} - count("lump", min(_tier, 9)))) * 4. > 2. * min(0., count("dust", _tier) - ({get_queue(_tier, ingot)})) & count("dust", _tier) < 2. * ({get_queue(_tier, ingot)})))
		previous_amount = count("dust", _tier)
		produce("dust", _tier, min(previous_amount - 1., {get_queue(_tier, ingot)}), "oven")
		{subtract_queue(_tier, ingot, previous_amount - count("dust", _tier))}
		noproduceingot:

		goto(if(_tier >= 10, 99, 1))
	};

	"craft": {
		:import factory constants
		:import recipes

		:name {script_name(craft)}

		:local double previous_amount
		:local int i
		:local string itemdata
		:local string group_data

		:global int factory_target

		key.{up}()
		key.{down}()

		isopen("factory")

		; If we were launched via key impulse, invoke the UI immediately to start turbo,
		; and set action to signal which key was pressed. Otherwise, we're being called
		; as a produce script.
		execute(if(contains(impulse(), "key."), "{script_name(ui)}", "###badname###"))
		gotoif(group_abort, contains(impulse(), "key."))

		; Craft all the items.
		craftitems_loop:
		itemdata = {lua(return factory.composite_string("i/10", "craft"))}

		do_craft:
		; Because items and tiers start at 1, but i is zero-based, we have to add 1
		; or (pre-multiplying, 10) in these expressions.
		; However, tier is zero-based inside our indexing representation, so we don't
		; add it there.
		previous_amount = count({get_name}, i%10 + 1)
		craft({get_name}, i%10 + 1, {get_raw(10 + i)})
		{set_raw(10 + i, {get_raw(10 + i)} - (count({get_name}, i%10 + 1) - previous_amount))}
		inc:
		; This skips over tiers that don't exist for the given item, by using the
		; tier data embedded in "itemdata".
		i = i + if(i2s(i%10) == {tiers_char}, 10 - i%10, 1)
		goto(if(i%10 != 0, \
			if({get_raw(10 + i)} > 0., do_craft, inc), \
			if(i < {items_count} * 10, craftitems_loop, crafting_done)))
		crafting_done:

		; Uncomment these lines for runtime item quantity debugging.
		; You will also need to uncomment the line in run_recipes that unhides debug.
		;i = 10
		;debug_loop:
		;gss("debug", if(i == 10, "", gsg("debug") . if({get_raw(i)} > 0., "<br>" . i . " " . {get_raw(i)}, "")))
		;i += 1
		;gotoif(debug_loop, i < {lua(return #factory.items)} * 10 + 10)

		group_data = "{lua(\
		acc = {}\
		for i = 1, #factory.items do\
			local item = factory.items[i];
			if item.craft_type != "group" then goto continue end\
			for j = 1, item.tier do\
				acc[#acc+1] = "|" .. (i * 10 + j + 99);
				local recipe = item.recipes[j];
				for k = 1, #recipe, 2 do\
				acc[#acc+1] = recipe[k] + 100;
				end\
			end\
			::continue::\
		end\
		acc[#acc+1] = "|";
		return table.concat(acc);
		)}"

		i = index(group_data, "|" . (factory_target + 100), 0) + 1
		check_group_loop:
		i += 3
		goto(if(\
		i < 4, group_abort, \
		if(\
			sub(group_data, i, 1) == "|", group_complete, \
			if(\
				gdg({queue_str} . sub(group_data, i, 3)) > 0., group_abort, \
				check_group_loop\
			)\
		)\
		))

		group_complete:
		{set_raw(factory_target, 0.)}
		group_abort:
		gss({action}, if(\
		contains(impulse(), "key."), \
		if(\
			contains(impulse(), "key.{up}"), \
			"1", \
			"-1"\
		), \
		gsg({action})\
		))
	};
	"init": {
		:import factory constants

		:name {script_name(init)}

		wakeup()
		open.factory()

		isopen("factory")

		:global double factory_target_amount
		:global int factory_target

		:global int turbo.cycles
		:global int turbo.cycles.max

		:local double target_value

		; Run the UI, to display the current pending item.
		execute("{script_name(ui)}")

		; Initial dispatch on entering the factory to determine if we are resuming
		; a crafting operation or waiting to launch a new one. This is done outside
		; of turbo, so that we never invoke turbo if we don't need to.
		gotoif(wait_loop, {get_raw(factory_target)} == 0.)

		; The core factory cycle. We do each loop of factory production within
		; one call of nested turbo start/stop, which executes within one frame.
		;
		; This loop handles both calculating recipes via "run_recipes"
		; and crafting via "craft". This is done with conditional execution,
		; in order to save lines for future possible features.
		begin_cycle:
		executesync("TE2.2:start")

		; Here we up the number of cycles so that it will be enough to
		; calculate the recipes or produce items. We intentionally have a
		; frame break between the recipe calculation and the beginning of crafting
		; to prevent jarring lag on startup.
		; This formula ensures that we don't accidentally step on another script
		; that needs more cycles, and also that we get the full amount of cycles
		; even if something else started turbo before us.
		turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)

		; We have to save this, because the value can change as a result of executing
		; later scripts.
		target_value = {get_raw(factory_target)}

		; All conditional execution in the loop is behind this condition. If it
		; is true, then we're here because of `ui`. Otherwise,
		; this is a regular crafting iteration.

		; There are extra checks for isopen("factory") here. The main check is at the
		; bottom of the loop, but that happens before the end of the frame, so there will
		; be one more frame where we have exited the factory, but the loop still runs.
		; Normally, this wouldn't be an issue (all of the scripts will perform no actions
		; and leave the variables in the same state), but "produce" and "craft" have a
		; startup condition of isopen("factory"), since they do double-duty as UI impulse
		; scripts as well.
		; So, we have to protect them, otherwise executesync() will hang when it hits
		; the false condition, leading to a stuck script.
		executesync(if(\
		isopen("factory"), \
		if(target_value > 0., "{script_name(produce)}", "{script_name(run_recipes)}"), \
		"###badname###"\
		))
		stop(if(target_value > 0., "{script_name(produce)}", "{script_name(run_recipes)}"))
		executesync(if(\
		target_value > 0. && isopen("factory"), \
		"{script_name(craft)}", \
		"###badname###"\
		))
		stop(if(target_value > 0., "{script_name(craft)}", "###badname###"))

		; Clear factory_target to indicate that crafting is done, if it is, in fact, done.
		factory_target = if({get_raw(factory_target)} > 0., factory_target, 0)
		; Re-display the UI when crafting is done.
		execute(if(factory_target == 0, "{script_name(ui)}", "###badname###"))

		; Clear this (unconditionally), to signal that we're not starting a new crafting
		; pass.
		factory_target_amount = 0.

		executesync("TE2.2:stop")

		; Here we either return to the next iteration of the production loop,
		; or stall on this instruction until we need to launch the factory.
		; Because there is always 1 extra cycle of turbo after "TE2.2:stop," there
		; is enough time to execute this goto and have only a single frame break
		; before starting turbo again at the top of the loop.
		wait_loop:
		gotoif(\
		if(max(factory_target_amount, {get_raw(factory_target)}) > 0., \
			begin_cycle, wait_loop\
		), \
		isopen("factory")\
		)

		; Remove the UI status so it doesn't clutter the variables when we're outside the
		; factory.
		; This is safe to repeat, when turbo is looping at the end of the script.
		gss({status}, "</size>")
	};
	"ui": {
		:import factory constants
		:import worker_storage_lib

		:name {script_name(ui)}

		:local double count
		:local int visible_tier
		:local int tier
		:local int category
		:local int item
		:local int cursor

		:global int turbo.cycles
		:global int turbo.register
		:global int factory_target
		:global double factory_target_amount

		key.{start}()

		isopen("factory")

		; Because of how turbo exec works, we can't launch turbo on the frame the script
		; starts by calling "TE2.2:start", if we are being called from another script.
		; We can only do it by changing turbo.register directly, saving a layer of
		; script execution.
		; (This is because of the relative positioning of TE.turbo vs our script;
		; usually we would be before, but when we are first launched our script is after.)
		turbo.register += 1

		; Use worker_storage_lib to find a worker_slot to use for permanent storage.
		:local int worker_slot
		{worker_lib_line_1([factory])}
		{worker_lib_line_2}

		; Split out the worker data into separate variables. We take advantage of this
		; time to also perform increment/decrement, since we can easily combine it in
		; this stage. We don't bother checking if we've got a valid slot, because if we
		; don't, we'll simply fail to parse and get the fallback value.

		#action_num s2i(gsg({action}), 0)
		; Is the u/d action valid for this position?
		; Using contains() instead of == and chained compares saves a lot of import space.
		#is_ud(pos) contains(impulse() . cursor, ":craft{pos}")

		cursor = min(9, max(0, \
		s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + 11, 1), 0) +\
		if(contains(impulse(), ":produce"), {action_num}, 0)\
		))
		count = min(9999999., max(1., \
		s2d(sub(worker.name(worker_slot), {len({worker_prefix})}, 7), 1.) +\
		if(contains(impulse(), ":craft"), i2d({action_num} * 10^(cursor - 3)), 0.)\
		))

		#num_categories {lua(return #factory.categories)}
		category = (\
		s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + 8, 1), 0) -\
		if({is_ud(1)}, {action_num}, 0) +\
		{num_categories}\
		) % {num_categories}

		; Because math expressions are so expensive, in terms of import space, it's best
		; to just pre-compute tables of the next/previous item to go to for every item.
		; To avoid duplicating expressions, we also make a no-op table for the case where
		; we're not incrementing or decrementing.
		{lua(\
		function factory.item_inc_table(inc)\
			local acc = {}\
			local default = string.format("%02d", factory.categories[1].default - 1)\
			for i = 1, #factory.categories do\
				local cat = factory.categories[i]\
				local cat_size = cat.last - cat.first + 1\
				for j = cat.first, cat.last do\
				acc[j] = string.format("%02d", (j + inc - cat.first) % cat_size + cat.first - 1)\
				end\
			end\
			for i = 1, #factory.items do\
				acc[i] = acc[i] or default\
			end\
			return table.concat(acc)\
		end\
		)}
		#item_inc_table(inc) {lua(return factory.item_inc_table({inc}))}
		#category_defaults {lua(\
		local acc = {}\
		for i = 1, #factory.categories do\
			acc[i] = string.format("%02d", factory.categories[i].default - 1)\
		end\
		return table.concat(acc)\
		)}

		; Items in this variable are zero-indexed, as opposed to their regular ids, which
		; start from 1.
		; We increment the items in the opposite direction from the action, because pressing
		; up (action 1) *increments* numerical values but *decrements* elements in an
		; alphabetically sorted list.
		item = s2i(\
		if({is_ud(1)}, \
			sub(\
				"{category_defaults}", \
				category * 2, \
				2\
			), \
			sub(\
				if({is_ud(0)}, \
				if(\
					contains(gsg({action}), "-1"), \
					"{item_inc_table(1)}", \
					"{item_inc_table(-1)}"\
				), \
				"{item_inc_table(0)}"\
				), \
				s2i(\
				sub(worker.name(worker_slot), {len({worker_prefix})} + 9, 2), \
				{lua(return factory.categories[1].default - 1)}\
				) * 2, \
				2\
			)\
		), \
		0\
		)

		; The distinction between "tier" and "visible_tier" has to do with the fact that
		; items have different tier maximums. When a user is scrolling through different
		; items, if the "tier" is T10 (represented as "9" in our zero-indexed scheme),
		; then the "visible_tier" will change to fit the maximum tier for the item, while
		; the tier remains at T10. However, if the item is a producer (max of T5), and
		; the user moves the cursor to the tier field and presses "W", the attempt to
		; increment "tier" will fix it at a new value of T5 (4).
		#tier_data {lua(\
		local acc = {};
		for i = 1, #factory.items do\
			local item = factory.items[i];
			acc[i] = string.format("%d", item.tier - 1);
		end\
		return table.concat(acc)\
		)}

		; Expression to load the saved tier data from the worker name, including
		; a default value when there is no data.
		#saved_worker_tier s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + 7, 1), 0)

		; It makes the most sense to set visible_tier first. There is a complication
		; when adjusting the tier down; in this case, we reduce the maximum bounds by
		; one, so that (for instance) if the max tier is T5, and the current tier is T10,
		; we'll properly clip the visible_tier to T4 after subtracting 1 to get T9.
		; This type of adjustment isn't needed (or wanted) in the other direction, or
		; when the tier isn't changing.
		visible_tier = max(0, \
		min(s2i(sub("{tier_data}", item, 1), 9) +\
				if({is_ud(2)} && gsg({action}) == "-1", -1, 0), \
			{saved_worker_tier} + if({is_ud(2)}, {action_num}, 0)\
		)\
		)
		tier = if({is_ud(2)}, visible_tier, {saved_worker_tier})

		; Finally, construct the visible name for use in the variable.
		{lua(\
		local names = {}\
		local name_starts = {}\
		local name_sizes = {}\
		local name_len = 0\
		\
		for i = 1, #factory.items do\
			local name = factory.items[i].name\
			names[i] = name\
			name_starts[i] = string.format("%03d", name_len)\
			name_len = name_len + #name\
			name_sizes[i] = string.format("%02d", #name)\
		end\
		factory.name_data = table.concat(names)\
		factory.name_starts = table.concat(name_starts)\
		factory.name_sizes = table.concat(name_sizes)\
		factory.items_count = #factory.items\
		\
		names = {}\
		for i = 1, #factory.categories do\
			names[i] = factory.categories[i].name\
		end\
		factory.category_names = table.concat(names)\
		)}
		#name_data {lua(return factory.name_data)}
		#name_starts {lua(return factory.name_starts)}
		#name_sizes {lua(return factory.name_sizes)}
		#category_names {lua(return factory.category_names)}

		; Set this variable in order to begin a variable-hiding block.
		; It looks like a no-op, but really we're ensuring that it has a slot in the
		; globals table, even if its value empty - in this case, what we care about
		; is the *name*, which starts with "<size=0>".
		; Do this *after* all the other work, to give turbo register time to
		; set its variables, in case we're doing this right at startup.
		gss({action}, gsg({action}))

		; Do conditional stuff, depending on if we're launching the factory.
		; We set all these variables always, so that they'll have a consistent order,
		; and also to save lines instead of jumping over this block.

		#valid_start contains(factory_target . impulse(), "0key.")
		; This (maybe) launches the factory. We need to do it soon enough to not
		; interrupt turbo, see the comment on "TE2.2:stop", below.
		{lua(\
		for i = 1, #factory.categories do\
			if factory.categories[i].name == "grup" then\
				grup_cat = i - 1;
				return;
			end\
		end\
		return "Couldn't find grup"\
		)}
		factory_target_amount = if(\
		{valid_start}, \
		count, \
		factory_target_amount\
		)

		; Only set factory_target if it's zero, which indicates that the factory is idle.
		; This prevents repeated keypresses from messing things up.
		factory_target = if({valid_start}, (item + 1) * 10 + visible_tier, factory_target)

		; Construct the status line. There's a *lot* that goes into this.
		;
		; For starters, we fake the variable - it's not really "make", but rather a
		; totally different variable that's less likely to collide. The true variable name
		; is never seen, because it's still part of the <size=0> block. We put our fake
		; variable name after. We do all this so that we can "unset" the variable by
		; just changing its value - this way, it's not truly unset, and we don't have
		; issues with variable ordering as a result.
		;
		; This also means we can change the variable name to something else, like
		; "error", if we need to, all without actually creating a new variable or
		; changing ordering.
		;
		; All the clauses are dynamically created on the fly here. We also create the
		; "cursor" by highlighting a specific part of the result in green. This involves
		; a great deal more complexity.
		#curs_col 2f4
		; For later - scanning rework
		;count_string if(category == {lua(return grup_cat)}, "  -SCAN-", d2s(10000000. + count))
		#count_string d2s(10000000. + count)

		gss({status}, if(\
		worker_slot == 200, \
		"</size>error=<color=#fb3>No available workers!</color>", \
		if(\
			turbo.cycles == 0, \
			"</size>error=<color=#fb3>Turbo exec is not working</color>", \
			"</size>make=<color=#fff>" .\
			sub({count_string}, 1, 9 - cursor) .\
			"</color><color=#{curs_col}>".\
			sub({count_string}, 10 - cursor, 1) .\
			"</color><color=#fff>".\
			sub({count_string}, 11 - cursor, 10) .\
			"<smallcaps>x</smallcaps><color=#" .\
			if(cursor == 2, "{curs_col}>T", "fff>T") .\
			(visible_tier + 1) .\
			if(cursor == 1, "</color> <color=#{curs_col}>", "</color> <color=#fff>") .\
			sub("{category_names}", category * 4, 4) .\
			if(cursor == 0, "</color> ...<br><color=#{curs_col}>", "</color> ...<br><color=#fff>") .\
			sub("{name_data}", s2i(sub("{name_starts}", item * 3, 3), 0), \
				s2i(sub("{name_sizes}", item * 2, 2), 0)) .\
			"<br></color></color>" . if(\
				contains(impulse() . gsg({action}), ":init<"), \
				gsg({action}), \
				if(\
				factory_target == 0, \
				"<color=#0df>{up}{left}{down}{right} moves, {start} crafts</color> ", \
				"<color=#ff0>Crafting...</color>"\
				)\
			)\
		)\
		))

		; Pause/unpause a dissolve worker, if it occupies our data slot.
		; If it's a different type of worker, leave it alone by dummying out the name.
		worker.pauseName(\
		if(\
			contains(worker.task(worker.name(worker_slot)), "factory.dissolveManagement"), \
			worker.name(worker_slot), \
			"![@#nosuchtask#@]!"\
		), \
		contains(gsg({status}), "Crafting")\
		)

		; "init" will take over as soon as factory_target_amount gets set 4 lines
		; above; it will call its own "TE2.2:start" and thus prevent the frame from
		; ending before this line takes effect.
		; We need two cycles in-between to have a seamless transition.
		; We change the variable directly, instead of calling "TE2.2:stop", for parity
		; with the way we start: This avoids some edge cases when turbo is incorrectly
		; installed. It also is fine in this case, because we don't need to wait for
		; the end of the frame.
		turbo.register -= 1

		; Setting the data back in the worker is moved way down to the bottom, to function
		; as the "filler" action that can be repeated while the script is waiting for
		; the frame to end. We can't use of the actions that set global variables for this,
		; because they may need to be modified later in the frame, and thus setting them
		; here in a loop would overwrite the value.
		worker.setName(if(worker_slot < 100, worker_slot, worker_slot - 100), \
		"{worker_prefix}" . sub(d2s(10000000. + count), 1, 7) . tier . category .\
		sub(i2s(100 + item), 1, 2) . cursor\
		)
	};
}