{
	"Adventure":{
		
		"analyze loot":{
			:import adventure_lib
			:name {package}:analyze loot
			
			:global string leon.adventure.targetPositions
			
			:local string queue
			:local string idx
			:local vector curPos
			:local string targetPos
			:local string lootPositions
			
			#setField(index, value) lss("_f" . {index}, {value})
			#getField(index) lsg("_f" . {index})
			#setTPos(index, value) lss("_t" . {index}, {value})
			#getTPos(index) lsg("_t" . {index})
			
			queue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . "S:"
			
			; On the first entry of this loop, the junk entry "_f" will be set to "S".
			; This has no effect.
			; In general, lootPositions, queue and setField are protected so that if the field
			; has already been set, we won't take action again.
			loop1:
			curPos = {firstElementPos}
			idx = sub(queue, 0, 4)
			lootPositions = if(\
				  {getField(idx)} == "" \
					 && contains(adventure.entityType(curPos), "Chest"), \
				  {posToString(x(curPos), y(curPos))} . ":", \
				  "") . lootPositions
			{setField(if({getField(idx)} != "", "", idx), {firstElementDir})}
			queue = sub(queue, 6, 99999) . if({getField(idx)} != {firstElementDir}, \
				  "", \
				  if(\
						 adventure.isWall(curPos + vec(0.0, 1.0)) || y(curPos) >= 18.0, \
						 "", \
						 {posToString(x(curPos), y(curPos) + 1.0)} . "U:" \
					  ) . if(\
						 adventure.isWall(curPos + vec(0.0, -1.0)) || y(curPos) < 1.0, \
						 "", \
						 {posToString(x(curPos), y(curPos) - 1.0)} . "D:" \
					  ) . if(\
						 adventure.isWall(curPos + vec(1.0, 0.0)) || x(curPos) >= 18.0, \
						 "", \
						 {posToString(x(curPos) + 1.0, y(curPos))} . "R:" \
					  ) . if(\
						 adventure.isWall(curPos + vec(-1.0, 0.0)) || x(curPos) < 1.0, \
						 "", \
						 {posToString(x(curPos) - 1.0, y(curPos))} . "L:" \
					  )\
				)
			gotoif(loop1, queue != "")
			
			continue:
			lootPositions = leon.adventure.targetPositions . lootPositions
			
			loop2:
			targetPos = sub(lootPositions, 0, 4)
			curPos = {strToVec(targetPos)}
			lootPositions = sub(lootPositions, 5, 99999)
			
			innerLoop2:
			idx = {posToString(x(curPos), y(curPos))}
			leon.adventure.targetPositions = if(\
				  {getField({posToString(\
									 x(curPos) - {nextX({getField(idx)})}, \
									 y(curPos) - {nextY({getField(idx)})} \
								  )})} == "S" \
					 && false == contains(leon.adventure.targetPositions, targetPos), \
				  targetPos . ":" . leon.adventure.targetPositions, \
				  if(\
						 false == contains(leon.adventure.targetPositions, targetPos)  \
							&& {getTPos(idx)} != "", \
							sub(\
								  leon.adventure.targetPositions, \
								  0, \
								  index(leon.adventure.targetPositions, {getTPos(idx)}, 0)\
								)\
							  . targetPos . ":" \
							  . sub(\
									 leon.adventure.targetPositions, \
									 index(leon.adventure.targetPositions, {getTPos(idx)}, 0), \
									 99999 \
								  ), \
						 leon.adventure.targetPositions \
					  )\
				)
			
			{setTPos(\
					  idx, \
					  if(\
							 false == contains(leon.adventure.targetPositions, targetPos)\
								|| {getTPos(idx)} == sub(leon.adventure.targetPositions, index(leon.adventure.targetPositions, targetPos, 0) + 5, 4), \
							 targetPos, \
							 {getTPos(idx)} \
						  )\
					)}
			curPos -= {nextDir({getField(idx)})}
			goto(if(\
					  {getField({posToString(x(curPos), y(curPos))})} != "S", \
					  innerLoop2, \
					  if(len(lootPositions) > 0, loop2, end)\
					))
			
			end:
			wait(0.0)};
		"clear room":{
			:import adventure_lib
			:name {package}:clear room
			
			:global int leon.adventure.maxDifficulty
			:global string leon.adventure.path
			:global string leon.adventure.targetPositions
			
			:global string leon.adventure.room_direction
			:local double difficulty
			
			#nextRoomLower if(\
				  x(adventure.roomCoords()) < 127.0 && y(adventure.roomCoords()) >= 127.0, \
				  "R", \
				  if(\
						 x(adventure.roomCoords()) >= 127.0 && y(adventure.roomCoords()) > 127.0, \
						 "D", \
						 if(\
								x(adventure.roomCoords()) > 127.0 && y(adventure.roomCoords()) <= 127.0, \
								"L", \
								"U"  \
							 )\
					  )\
				)
			#rotateLeft(x) sub("LDRU", index("ULDR", {x}, 0), 1)
			#condRotateLeft(cond, x) sub(if({cond}, "LDRU", "ULDR"), index("ULDR", {x}, 0), 1)
			
			executesync("{package}:farm keys")
			
			; We check based on current difficulty plus 1, because it's more efficient
			; that way.
			difficulty = {cur_difficulty(1.0)}
			leon.adventure.room_direction = if(\
				  difficulty == 1.0 && leon.adventure.room_direction != "", \
				  {rotateLeft(leon.adventure.room_direction)}, \
				  {condRotateLeft({survivable(difficulty)}, {nextRoomLower})} \
				)
			
			leon.adventure.targetPositions = sub(\
					 "0918 0009 1809 0900", \
					 index("U	 L	 R	 D", leon.adventure.room_direction, 0), \
					 4 \
				) . ":"
			
			executesync("{package}:find loot")
			leon.adventure.path = leon.adventure.room_direction
			executesync("{package}:follow path")
			end:
			wait(0.0)};
		"farm keys":{
			:import adventure_lib
			:name {package}:farm keys
			
			:global string leon.adventure.path
			:global bool leon.adventure.running
			:global int leon.adventure.maxDifficulty
			
			:local double difficulty
			:local bool parity
			:local bool needs_something
			:local bool skipped
			
			:local string dir
			
			#needs_bombs adventure.bombs() < 99 && difficulty >= 80.0 && adventure.hasItem("leechSword")
			#needs_health adventure.playerHealth() < 99 && adventure.hasItem("leechSword")
			#needs_mana adventure.mana() < 99 && adventure.hasItem("manaReaver")
			#needs_keys adventure.keys() <= 10
			#num_enemies round(difficulty * 0.1 + 3.0)
			#elite_dmg d2i(floor(difficulty * 0.01 + 1.0)) * (d2i(ceil(ceil(difficulty * 0.39) * 1.5)) - adventure.playerArmor())
			
			goto(start)
			
			next:
			parity = false == parity
			leon.adventure.path = dir
			executesync("{package}:follow path")
			start:
			difficulty = {cur_difficulty(0.0)}
			needs_something = {survivable(difficulty)} && ({needs_bombs} || {needs_health} || {needs_mana} || {needs_keys})
			dir = sub("XU	D  L  R", index(" 918 90 09 189", x(adventure.playerPos()) . y(adventure.playerPos()), 0), 1)
			skipped = contains("UDLR", dir) && (\
				  (adventure.countEntities("Elite") > 0) != ({needs_bombs})\
					 && (adventure.countEntities("Elite") > 0 || adventure.playerHealth() > 100 - d2i({num_enemies} * 1.8))\
					 || (adventure.countEntities("Elite") > 0 && adventure.playerHealth() <= {elite_dmg})\
					 || (parity && false == needs_something)\
				)
			executesync(if(skipped, "{package}:xNOOPx", "{package}:kill enemies"))
			; Update needs_something after clearing
			goto(if(\
					  contains("UDLR", dir) && leon.adventure.running && (\
							 needs_something && ({needs_bombs} || {needs_health} || {needs_mana} || {needs_keys})\
								|| parity \
								|| skipped \
						  ), \
					  next, \
					  end \
					))
			end:
			wait(0.0)};
		"find loot":{
			:import adventure_lib
			:name {package}:find loot
			
			:global int turbo.cycles.max
			:global int turbo.cycles
			:global bool leon.adventure.running
			:global string leon.adventure.targetPositions
			:global int leon.adventure.maxDifficulty
			
			key.u()
			key.j()
			
			isopen("arcade")
			
			leon.adventure.maxDifficulty += \
			  if(contains(impulse(), "key.j"), -1, if(contains(impulse(), "key.u"), 1, 0))
			gotoif(end, contains(impulse(), "key."))
			
			start:
			turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)
			executesync("{package}:analyze loot")
			loop:
			executesync("{package}:find path")
			executesync("{package}:follow path")
			leon.adventure.targetPositions = sub(leon.adventure.targetPositions, 5, 99999)
			gotoif(loop, len(leon.adventure.targetPositions) > 0 && leon.adventure.running)
			end:
			wait(0.0)};
		"find path":{
			:import adventure_lib
			:name {package}:find path
			
			:global string leon.adventure.path
			:global string leon.adventure.targetPositions
			:global int turbo.cycles.max
			:global int turbo.cycles
			
			:local vector curPos
			:local string queue
			:local string idx
			:local string dir
			:local string path
			:local bool cantPhase
			
			#setField(index, value) lss("_f" . {index}, {value})
			#getField(index) lsg("_f" . {index})
			
			turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)
			leon.adventure.path = ""
			cantPhase = false == adventure.hasItem("bootsPhasing")\
			|| 0 < max(\
				  max(\
						 max(\
								adventure.countEntities("Chest"), \
								adventure.countEntities("Enemy")\
							 ), \
						 adventure.countEntities("Elite")\
					  ), \
				  adventure.countEntities("Mimic")\
				)
			queue = {posToString(x(adventure.playerPos()), y(adventure.playerPos()))} . "S:"
			loop1:
			curPos = {firstElementPos}
			idx = sub(queue, 0, 4)
			{setField(if({getField(idx)} != "", "", idx), {firstElementDir})}
			queue = sub(queue, 6, 99999) . if({getField(idx)} != {firstElementDir}, \
				  "", \
				  if(\
						 adventure.isWall(curPos + vec(0.0, 1.0)) && cantPhase \
							|| max(x(curPos), y(curPos)) >= 18. \
							|| x(curPos) < 1.0, \
						 "", \
						 {posToString(x(curPos), y(curPos) + 1.0)} . "U:" \
					  ) . if(\
						 adventure.isWall(curPos + vec(0.0, -1.0)) && cantPhase \
							|| min(x(curPos), y(curPos)) < 1. \
							|| x(curPos) >= 18.0, \
						 "", \
						 {posToString(x(curPos), y(curPos) - 1.0)} . "D:" \
					  ) . if(\
						 adventure.isWall(curPos + vec(1.0, 0.0)) && cantPhase \
							|| max(x(curPos), y(curPos)) >= 18. \
							|| y(curPos) < 1.0, \
						 "", \
						 {posToString(x(curPos) + 1.0, y(curPos))} . "R:" \
					  ) . if(\
						 adventure.isWall(curPos + vec(-1.0, 0.0)) && cantPhase \
							|| min(x(curPos), y(curPos)) < 1. \
							|| y(curPos) >= 18.0, \
						 "", \
						 {posToString(x(curPos) - 1.0, y(curPos))} . "L:" \
					  )\
				)
			goto(if(\
					  queue == "" || contains(idx, sub(leon.adventure.targetPositions, 0, 4)), \
					  l2start, \
					  loop1 \
					))
			
			loop2:
			leon.adventure.path = dir . leon.adventure.path
			curPos -= {nextDir(dir)}
			idx = {posToString(x(curPos), y(curPos))}
			l2start:
			dir = {getField(idx)}
			gotoif(loop2, dir != "S")
			
			executesync("{package}:refine path")
			wait(0.0)};
		"follow path":{
			:import adventure_lib
			:name {package}:follow path
			
			:global string leon.adventure.path
			:global bool leon.adventure.running
			
			:local int stepCount
			:local vector curPos
			:local bool waitChest
			:local vector nextMove
			
			#nextDirection sub(leon.adventure.path, stepCount, 1)
			#nextMove {nextDir({nextDirection})}
			#curEntity adventure.entityType(curPos + {nextDir({nextDirection})})
			
			goto(start)
			
			bomb:
			adventure.placeBomb()
			goto(move)
			
			wait:
			adventure.wait()
			
			move:
			stepCount += 1
			start:
			curPos = adventure.playerPos()
			nextMove = {nextMove}
			waitChest = contains(adventure.entityType(adventure.playerPos() + nextMove), "Chest")
			
			move2:
			executesync("TE2.2:stop")
			adventure.move(nextMove)  ; This is a no-op for invalid (0,0) moves
			executesync("TE2.2:start")
			
			loop:
			; This uses the spacing of unused values in the index expression to be equivalent
			; to lines to skip *backward*. This is much cheaper than having a nested ternary.
			; index returns -1 for the fallthrough case. (UDLR -> move)
			goto(if(\
					  stepCount < len(leon.adventure.path) && leon.adventure.running, \
					  if(\
							 contains("BW", {nextDirection})\
								|| x(curPos) != x(adventure.playerPos())\
								|| y(curPos) != y(adventure.playerPos())\
								|| waitChest && adventure.entityType(adventure.playerPos() + nextMove) == "", \
							 (move - 1) - index("W B", {nextDirection}, 0), \
							 move2 \
						  ), \
					  end \
					))
			
			end:
			wait(0.0)};
		"init":{
			:import adventure_lib
			:name {package}:init
			
			:global double leon.adventure.delay
			:global string leon.adventure.path
			:global bool leon.adventure.running
			:global int leon.adventure.maxDifficulty
			:global string leon.adventure.targetPositions
			:global string leon.adventure.room_direction
			:local int maxDifficultyInit
			
			key.r()
			key.i()
			
			isopen("arcade")
			
			maxDifficultyInit = 81
			leon.adventure.maxDifficulty = if(\
				  contains(impulse(), "key.i") || leon.adventure.maxDifficulty == 0, \
				  maxDifficultyInit, \
				  leon.adventure.maxDifficulty \
				)
			
			goto(if(\
					  contains(impulse(), "key.i"), \
					  end, \
					  if(leon.adventure.running, stop, start)\
					))
			start:
			executesync("TE2.2:start")
			gis("<size=0>leon.adventure",0)
			leon.adventure.running = true
			leon.adventure.path = ""
			leon.adventure.targetPositions = ""
			leon.adventure.room_direction = ""
			gss("---Stop hiding---", "</size=0>")
			loop:
			executesync("{package}:clear room")
			leon.adventure.maxDifficulty = leon.adventure.maxDifficulty + if(\
				  {cur_difficulty(0.0)} >= i2d(leon.adventure.maxDifficulty)\
					 && adventure.isCompleted(adventure.roomCoords()), \
				  2, \
				  0 \
				)
			gotoif(loop, leon.adventure.running)
			executesync("TE2.2:stop")
			stop:
			leon.adventure.running = false
			end:
			wait(0.0)};
		"kill enemies":{
			:import adventure_lib
			:name {package}:kill enemies
			
			#enemyInDir(x, y) adventure.isEnemy(adventure.playerPos() + vec({x},{y}))
			#enemyDirection if({enemyInDir(0.0, 1.0)}, vec(0.0, 1.0), \
					 if({enemyInDir(1.0, 0.0)}, vec(1.0, 0.0), \
						 if({enemyInDir(0.0, -1.0)}, vec(0.0, -1.0), \
							 if({enemyInDir(-1.0, 0.0)}, vec(-1.0, 0.0), vec(0.0, 0.0)))))
			#anyEnemies {enemyInDir(0.0, 1.0)} || {enemyInDir(0.0, -1.0)} || {enemyInDir(1.0, 0.0)} || {enemyInDir(-1.0, 0.0)}
			
			key.k()
			
			isopen("arcade")
			
			goto(if(contains(impulse(), "key."), turbostart, loop))
			wait:
			adventure.wait()
			
			attack:
			executesync("TE2.2:stop")
			adventure.move({enemyDirection})
			
			turbostart:
			executesync("TE2.2:start")
			
			loop:
			goto(if(\
					  {anyEnemies}, \
					  attack, \
					  if(\
							 max(max(adventure.countEntities("Enemy"), adventure.countEntities("Elite")), adventure.countEntities("Mimic")) > 0, \
							 wait, \
							 if(contains(impulse(), "key."), stop, end)\
						  )\
					))
			stop:
			executesync("TE2.2:stop")
			end:
			wait(0.0)};
		"refine path":{
			:import adventure_lib
			:name {package}:refine path
			
			:global string leon.adventure.path
			
			:local vector curPos
			:local int stepCount
			
			#curDirection sub(leon.adventure.path, stepCount, 1)
			#insert(st,i,val) sub({st},0,{i}) . ({val}) . sub({st},{i},99999)
			#escapeDirection if(\
				  adventure.entityType(curPos + vec(0.0, 1.0)) == "" \
					 && adventure.entityType(curPos + vec(0.0, 2.0)) == "" \
					 && false == adventure.isWall(curPos + vec(0.0, 1.0))\
					 && y(curPos) < 17.0, \
				  "BUUWDD", \
				  if(\
						 adventure.entityType(curPos + vec(0.0, -1.0)) == "" \
							&& adventure.entityType(curPos + vec(0.0, -2.0)) == "" \
							&& false == adventure.isWall(curPos + vec(0.0, -1.0))\
							&& y(curPos) > 1.0, \
						 "BDDWUU", \
						 if(\
								adventure.entityType(curPos + vec(-1.0, 0.0)) == "" \
								  && adventure.entityType(curPos + vec(-2.0, 0.0)) == "" \
								  && false == adventure.isWall(curPos + vec(-1.0, 0.0))\
								  && x(curPos) > 1.0, \
								"BLLWRR", \
								"BRRWLL" \
							 )\
					  )\
				)
			
			curPos = adventure.playerPos()
			goto(start)
			
			rock:
			leon.adventure.path = {insert(\
					  leon.adventure.path, \
					  stepCount, \
					  if(adventure.hasItem("eodArmor"), "BWWW", {escapeDirection})\
					)}
			stepCount += if(adventure.hasItem("eodArmor"), 4, 6)
			
			nextTile:
			curPos += {nextDir({curDirection})}
			stepCount += 1
			
			start:
			goto(if(\
					  stepCount >= len(leon.adventure.path), \
					  end, \
					  if(\
							 adventure.entityType(curPos + {nextDir({curDirection})}) != "Rock" || adventure.hasItem("hammer"), \
							 nextTile, \
							 rock \
						  )\
					))
			end:
				 wait(0.0)};
		"adventure_lib":{
			#package Adventure v3.2
			
			#strToVec(str) vec(s2d(sub({str}, 0, 2), -1.0), s2d(sub({str}, 2, 2), -1.0))
			#posToString(x, y) sub(d2s(({x}) + 200.0), 1, 2) . sub(d2s(({y}) + 200.0), 1, 2)
			#firstElementPos {strToVec(queue)}
			#firstElementDir sub(queue, 4, 1)
			#cur_difficulty(offset) (max(254.0 - x(adventure.roomCoords()), x(adventure.roomCoords())) + max(254.0 - y(adventure.roomCoords()), y(adventure.roomCoords())) + ({offset} - 254.0))
			#survivable(difficulty) (\
				  ceil(i2d(adventure.playerAttack()) * if(adventure.hasItem("impaler"), 1.1, 1.0)) >= \
					 round({difficulty} * 0.38 + 1.0) + round({difficulty} * 0.08)\
					 || i2d(adventure.playerArmor()) >= ceil({difficulty} * 0.39)\
				) && i2d(leon.adventure.maxDifficulty) >= {difficulty} \
			  && (adventure.hasItem("lantern") || {difficulty} < 100.0)
			#nextX(d) s2d(sub("X 0 0 1-1", index(" U D R L", {d}, 0), 2), 0.0)
			#nextY(d) s2d(sub("X 1-1 0 0", index(" U D R L", {d}, 0), 2), 0.0)
			#nextDir(d) vec({nextX({d})}, {nextY({d})})};
		};
	};
{
	"TE2.2":{
		
		"turbo_2.2_start":{
			:name TE2.2:start
			
			; This script registers a script for turbo exec, and exits as soon it confirms
			; turbo exec is running.
			; When executing this script, it is highly advised to execute it using
			; `execute(sync)` as among other things, this guarantees that the cycle counter
			; has started and that it is safe to overwrite `turbo.cycles.max` with a new
			; maximum value.
			
			
			; This variable is used to track how many scripts are using turbo exec.
			; It's incremented each time `TE2.2:start` is called, and decremented
			; every time `TE2.2:stop` is called. When it reaches 0, turbo is stopped
			; and waits for the next script to register.
			:global int turbo.register
			
			; This variable is used to recieve state information from `<turbo>:register`.
			:global string turbo.state
			
			turbo.register += 1 ; Increment the registry counter
			
			; This should guarantee turbo exec is up and is gonna keep running until
			; the next call to `TE2.2:stop` (assuming no script interferes or causes
				; undefined behavior).
			; For instance, if `TE2.2:start` is called shortly before cycles.max is
			; reached (due to another script using turbo), without this check it would
			; return just as turbo is stopping.
			; `goto` is being used here to stay consistent with `TE2.2:stop`.
			wait:
			goto(if(contains(turbo.state, "running"), end, wait))
			
			; Finishing the script with a noop is important, else the script will get
			; stuck on the `goto` even after turbo finished.
			wait(0.0)
			end:};
		"turbo_2.2_stop":{
			:name TE2.2:stop
			
			; This script unregisters a script for turbo exec, signaling that the caller
			; script wishes to resume normal execution now, thus, this script only exits
			; once it confirms that turbo isn't running anymore.
			; When executing this script, it is highly advised to execute it using
			; `execute(sync)`. This is especially important if you are gonna start turbo
			; again soon after, as this guarantees that a frame skip does happen and thus
			; prevents infinite loops, and, if you care about it, this
			; guarantees frame continuity as long as you call `TE2.2:start` again within
			; the next 2 instructions after this script returns.
			
			
			; This variable is used to track how many scripts are using turbo exec.
			; It's incremented each time `TE2.2:start` is called, and decremented
			; everytime `TE2.2:stop` is called. When it reaches 0, turbo is stopped
			; and waits for the next script to register.
			:global int turbo.register
			
			; This variable is used to recieve state information from `<turbo>:register`.
			:global string turbo.state
			
			; Decrement the registry counter. There intentionally isn't a check for
			; negative, because if the calls are unbalanced that behavior should be
			; exposed quickly so it can be found and fixed.
			turbo.register -= 1
			
			; `turbo.state` first goes through the state "stopping", which happens 1 cycle
			; early. By exiting one cycle early, the caller script has a 1 cycle buffer to
			; call `turbo start` again to preserve frame continuity, but since the frame
			; skip is already planned at that point, even if the caller calls `turbo start`
			; right after this exits, the frame will be skipped correctly. This allows more
			; versatility in the caller's syntax and can save some crucial lines.
			; It is important to use `goto` here instead of `waituntil`, otherwise the extra
			; cycle would be consumed by waiting for the extra noop instruction at the end.
			wait:
			goto(if(contains(turbo.state, "running"), wait, end))
			
			; Finishing the script with a noop is important, else the script will get
			; stuck on the `goto` even after turbo finished.
			wait(0.0)
			end:};
		"turbo_register":{
			:name TE2.2:register
			
			; This script is the main manager script, it runs the main turbo loop when
			; needed and sends state information to other scripts.
			
			
			; This variable is used to track how many scripts are using turbo exec,
			; it's incremented each time `TE2.2:start` is called, and decremented
			; everytime `TE2.2:stop` is called. When it reaches 0, turbo is stopped
			; and waits for the next script to register.
			:global int turbo.register
			
			; This variable is used to communicate state with other scripts in turbo,
			; there are 4 states possible :
			; "stopping" means turbo should stop on the next cycle, this state is used to
			;	  allow a 1-cycle delay on when `TE2.2:start` needs to be called to
			;	  guarantee that one and only one frame passed from the last `TE2.2:stop`.
			; "active" means that this cycle is a "breaking" cycle, and forces advancing
			;	  to the next frame. The name is chosen because this is what will usually
			;	  appear in the variable display when turbo is active.
			; "idle" means that turbo is idle and waiting for the next script to register
			; "running" means that turbo is currently running. Note that this state will
			;	  never show in the variable display!
			:global string turbo.state
			
			; This variable counts the number of cycles since the beginning of the frame,
			; although it does have a delay of a few cycles, this doesn't matter for its
			; 2 main applications, which are :
			; - making sure turbo doesn't run for too long
			; - allowing scripts to calculate how many cycles passed between 2 instructions
			:global int turbo.cycles
			; This variable determines how many cycles turbo is allowed to run for at most
			; on this frame. It is reset each frame. If your script needs turbo to run for
			; longer then 200 cycles per frame, you need to set that using this variable.
			; To prevent conflicts with other scripts, please make sure to use the
			; following instruction to require more cycles :
			;
			; turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + cycles_you_require)
			;
			; The reason we add the current number of cycles to the required cycles is
			; that turbo exec might have already been running for a while due to another
			; script requiring it. If that is the case, we want to make sure we extend
			; `turbo.cycles.max` enough to run all the computation and actions we still
			; need to do.
			;
			; There is also a hard-coded limit of 50000 cycles to prevent the game from
			; freezing in case a script messed up.
			:global int turbo.cycles.max
			
			wakeup()
			
			turbo.register = 0
			
			; Kill TE2.1 scripts if they're present, to avoid compatibility issues.
			; TE2.2 and TE2.1 are identical, aside from TE2.2 being in a package, so
			; the v2.2 version can handle all the logic.
			; Wait one cycle (by setting `turbo.register` first) to avoid script-ordering
			; issues; this guarantees that the other scripts have already started, if they
			; are present. The stops must also be ordered this way to always work correctly.
			stop("TE2.1 register")
			stop("TE2.1")
			
			turbo.state = "idle"
			turbo.cycles.max = 200
			wait:
			waituntil(turbo.register > 0) ; Wait for a script to register
			skipwait:
			execute("TE2.2:counting");
			
			turbo.state = "running"
			
			; Reset cycles.max to its default value at the start of each frame, even if a
			; script fails to call `TE2.2:stop` in time, it's better to reset this value
			; as the script is already in undefined behavior territory and it's preferable
			; to not hold back other scripts because of a defective script.
			; Because this is set right after `turbo.state`, even if a script tries to
			; overwrite this right after calling `TE2.2:start`, this won't cause a race
			; condition (assuming `TE2.2:start` was executed using `execute(sync)`).
			turbo.cycles.max = 200
			
			; Wait for conditions to end the frame.
			; This is written oddly, with "min" instead of "||", because "||" is actually
			; a trinary function and thus slower to execute. Every bit counts here in
			; the hottest cycle of turbo.
			waituntil(0 >= min(turbo.register, min(turbo.cycles.max, 50000) - turbo.cycles))
			
			; This doesn't look like much, but this is the most crucial part of this
			; script, by signaling scripts 2 cycle earlier, and going through 4 different
			; states, we enable the groundwork for a lot of QOL features and optimizations.
			; The reason we need to buffer for 2 cycles is that one of the cycles is used up
			; when `execsync("TE2.2:stop")` ends.
			
			turbo.state = "stopping" ; About to change to the next frame
			wait(0.0)					 ; Buffered instructions
			turbo.state = "active"	; Changing to the next frame on this cycle
			turbo.state = "idle"	  ; Idle state, waiting for registration
			
			; Save a cycle if registration already happened
			goto(if(turbo.register > 0, skipwait, wait))};
		"turbo":{
			:name TE2.2:turbo
			
			; This script combined with `TE2.2:active` forms the core of turbo exec v2.
			; Be careful: If it remains in "turbo" mode without ever changing state,
			; the game is gonna freeze and then crash.
			
			; The number of scripts using turbo exec.
			:global int turbo.register
			
			; This variable is used to recieve state information from `<turbo>:register`
			:global string turbo.state
			
			wakeup()
			
			; To function, this operates closely coupled with `TE2.2:active`, which has a
			; single instruction: execute("TE2.2:turbo")
			;
			; To understand how this functions, first understand that there are exactly
			; two states that the scripts can be in after a cycle: Either
			; 1) `TE2.2:turbo` is about to run line #2, and `TE2.2:active` isn't running.
		; 2) `TE2.2:active` is about to run line #1, and `TE2.2:turbo` isn't running.
	;
	; Every cycle, `TE2.2:active` runs its action, either because it was already
	; running or because it is executed by `TE2.2:turbo` on line #2.0 This launches
	; a new copy of `TE2.2:turbo`, and the new state is completely determined by
	; the "if" condition on line #1.
	;
	; If the "if" is true, `TE2.2:turbo` is stopped, which causes "turbo exec" behaviour
	; because a script is stopping itself: The current script pointer is reset to
	; the beginning, effectively giving a "free" cycle to all scripts before it in
	; the script list. The turbo exec bug/feature also prevents scripts at the end
	; from exiting, so `TE2.2:active` will remain on line #1.
	;
	; If the "if" is false, `TE2.2:active` is stopped, and `TE2.2:turbo` will
	; execute line #2 next frame. This is "regular execution mode."
	;
	; A side-effect of the way this works is that `TE2.2:turbo` is the only script that
	; will be running at the end of a frame, so it is the only one that will ever
	; be visible in the scripts list.
	;
	; The "contains" is an optimization for checking multiple values at once. AI
	; performance is based on how many "nodes" are evaluated, and boolean
	; operations like "||" are actually trinary functions, and thus surprisingly
	; expensive. The concat with [] is necessary to avoid matching when
	; turbo.state is empty, which happens on startup.
	; In most places, readability matters more, but here in the hottest loop of
	; turbo, every bit counts.
	
	stop(if(contains("[running][stopping]", "[" . turbo.state . "]") || contains(turbo.state, "idle") && turbo.register > 0, "TE2.2:turbo", "TE2.2:active"))
	execute("TE2.2:active")};
"turbo_active":{
	:name TE2.2:active
	
	; This script combined with turbo forms the core of turbo exec v2.
	; To understand how it works, see turbo.tpt2.
	
	execute("TE2.2:turbo")};
"turbo_counting":{
	:name TE2.2:counting
	
	; This script counts the number of elapsed cycles since its execution.
	; This is used to halt turbo if it runs for too long.
	
	:global int turbo.cycles
	
	turbo.cycles = 0
	turbo.cycles += 1
	; Since scripts aren't removed from the script list as long as turbo is
	; running, their last instructions are instead run every cycle. This allows
	; repeating the same instruction each cycle.};
"turbo_start":{
	:name turbo start
	
	; This script is a compatibility script for supporting TE2.1 scripts.
	; It performs the same functions as TE2.2:start, but with a different
	; script name.
	
	
	; This variable is used to track how many scripts are using turbo exec.
	; It's incremented each time `turbo start` is called, and decremented
	; every time `turbo stop` is called. When it reaches 0, turbo is stopped
	; and waits for the next script to register.
	:global int turbo.register
	
	; This variable is used to recieve state information from `<turbo> register`.
	:global string turbo.state
	
	turbo.register += 1 ; Increment the registry counter
	
	; This should guarantee turbo exec is up and is gonna keep running until
	; the next call to `turbo stop` (assuming no script interferes or causes
		; undefined behavior).
	; For instance, if `turbo start` is called shortly before cycles.max is
	; reached (due to another script using turbo), without this check it would
	; return just as turbo is stopping.
	; `goto` is being used here to stay consistent with `turbo stop`.
	wait:
	goto(if(contains(turbo.state, "running"), end, wait))
	
	; Finishing the script with a noop is important, else the script will get
	; stuck on the `goto` even after turbo finished.
	wait(0.0)
	end:};
"turbo_stop":{
	:name turbo stop
	
	; This script is a compatibility script for supporting TE2.1 scripts.
	; It performs the same functions as TE2.2:stop, but with a different
	; script name.
	
	
	; This variable is used to track how many scripts are using turbo exec.
	; It's incremented each time `turbo start` is called, and decremented
	; everytime `turbo stop` is called. When it reaches 0, turbo is stopped
	; and waits for the next script to register.
	:global int turbo.register
	
	; This variable is used to recieve state information from `<turbo> register`.
	:global string turbo.state
	
	; Decrement the registry counter. There intentionally isn't a check for
	; negative, because if the calls are unbalanced that behavior should be
	; exposed quickly so it can be found and fixed.
	turbo.register -= 1
	
	; `turbo.state` first goes through the state "stopping", which happens 1 cycle
	; early. By exiting one cycle early, the caller script has a 1 cycle buffer to
	; call `turbo start` again to preserve frame continuity, but since the frame
	; skip is already planned at that point, even if the caller calls `turbo start`
	; right after this exits, the frame will be skipped correctly. This allows more
	; versatility in the caller's syntax and can save some crucial lines.
	; It is important to use `goto` here instead of `waituntil`, otherwise the extra
	; cycle would be consumed by waiting for the extra noop instruction at the end.
	wait:
	goto(if(contains(turbo.state, "running"), wait, end))
	
	; Finishing the script with a noop is important, else the script will get
	; stuck on the `goto` even after turbo finished.
	wait(0.0)
	end:};
};
}